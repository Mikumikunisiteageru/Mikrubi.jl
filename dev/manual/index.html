<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Manual · Mikrubi.jl</title><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.045/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.24/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../">Mikrubi.jl</a></span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li class="is-active"><a class="tocitem" href>Manual</a><ul class="internal"><li><a class="tocitem" href="#Reading-and-writing"><span>Reading and writing</span></a></li><li><a class="tocitem" href="#Rasterizing-a-shapefile"><span>Rasterizing a shapefile</span></a></li><li><a class="tocitem" href="#makefield"><span>Processing the raster layers</span></a></li><li><a class="tocitem" href="#The-Mikrubi-core"><span>The Mikrubi core</span></a></li></ul></li><li><a class="tocitem" href="../graphics/">Graphics</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Manual</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Manual</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/Mikumikunisiteageru/Mikrubi.jl/blob/master/docs/src/manual.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Manual"><a class="docs-heading-anchor" href="#Manual">Manual</a><a id="Manual-1"></a><a class="docs-heading-anchor-permalink" href="#Manual" title="Permalink"></a></h1><ul><li><a href="#Manual">Manual</a></li><li class="no-marker"><ul><li><a href="#Reading-and-writing">Reading and writing</a></li><li class="no-marker"><ul><li><a href="#Reading-and-searching-shapefile">Reading and searching shapefile</a></li><li><a href="#Reading-and-writing-list-file">Reading and writing list file</a></li><li><a href="#Reading-and-writing-raster-layers">Reading and writing raster layers</a></li><li><a href="#Reading-and-writing-Mikrubi-fields">Reading and writing Mikrubi fields</a></li><li><a href="#Reading-and-writing-Mikrubi-models">Reading and writing Mikrubi models</a></li></ul></li><li><a href="#Rasterizing-a-shapefile">Rasterizing a shapefile</a></li><li><a href="#makefield">Processing the raster layers</a></li><li><a href="#The-Mikrubi-core">The Mikrubi core</a></li><li class="no-marker"><ul><li><a href="#Mikrubi-field">Mikrubi field</a></li><li><a href="#Mikrubi-model">Mikrubi model</a></li><li><a href="#fitfuncm">Fitting a Mikrubi model</a></li><li><a href="#Predicting-from-a-Mikrubi-model">Predicting from a Mikrubi model</a></li><li><a href="#Sampling-counties-in-a-Mikrubi-field">Sampling counties in a Mikrubi field</a></li><li><a href="#Detecting-overfitting">Detecting overfitting</a></li></ul></li></ul></li></ul><h2 id="Reading-and-writing"><a class="docs-heading-anchor" href="#Reading-and-writing">Reading and writing</a><a id="Reading-and-writing-1"></a><a class="docs-heading-anchor-permalink" href="#Reading-and-writing" title="Permalink"></a></h2><h3 id="Reading-and-searching-shapefile"><a class="docs-heading-anchor" href="#Reading-and-searching-shapefile">Reading and searching shapefile</a><a id="Reading-and-searching-shapefile-1"></a><a class="docs-heading-anchor-permalink" href="#Reading-and-searching-shapefile" title="Permalink"></a></h3><p>Since shape files are always read instead of written in this application, only the reading function <a href="#Mikrubi.readshape"><code>readshape</code></a> is provided. </p><article class="docstring"><header><a class="docstring-binding" id="Mikrubi.readshape" href="#Mikrubi.readshape"><code>Mikrubi.readshape</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">readshape(path::AbstractString, index::Int=-1; 
	extset = [&quot;.shp&quot;, &quot;.geojson&quot;, &quot;.gpkg&quot;]) :: AG.IFeatureLayer</code></pre><p>Read a shape file located at <code>path</code>. If <code>path</code> refers to a file, the file is  directly read; otherwise, if <code>path</code> refers to a directory, a random shape file  inside is read. </p><p><code>extset</code> describes possible extensions of shape files (see also  <a href="#Mikrubi.readlayers"><code>readlayers</code></a>). By setting <code>extset</code> to <code>nothing</code>, the extension  filtering is not processed, i.e., all files are regarded as shape files.  <code>extset</code> is indifferent when <code>path</code> refers to a file. </p><p>The shape file should contain a dataset. When the dataset consists of multiple  layers, <code>index</code> indicates which data layer should be returned. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Mikumikunisiteageru/Mikrubi.jl/blob/c0c0148e2c54247a8d57189244738c548da2de24/src/shape.jl#L19-L34">source</a></section></article><p>The function <a href="#Mikrubi.lookup"><code>lookup</code></a> is useful when some attribute (e.g. name or code) of a county is known and the row number of the county in a shapefile is wanted (row number may act as identifiers in the list of occupied counties, see the syntax of <a href="#Mikrubi.fit"><code>fit</code></a>). </p><article class="docstring"><header><a class="docstring-binding" id="Mikrubi.lookup" href="#Mikrubi.lookup"><code>Mikrubi.lookup</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">lookup(shptable::AG.IFeatureLayer, 
	column::Union{AbstractString, Symbol}, entry)
lookup(shptable::AG.IFeatureLayer, 
	column::Union{AbstractString, Symbol}, entries::AbstractArray)
lookup(shptable::AG.IFeatureLayer)</code></pre><p>Find row(s) in the shape table whose <code>column</code> record(s) equal(s) to <code>entry</code>  or elements of <code>entries</code>. When the third argument is an array, results are  output as an array of the same shape by broadcasting. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Mikumikunisiteageru/Mikrubi.jl/blob/c0c0148e2c54247a8d57189244738c548da2de24/src/shape.jl#L84-L94">source</a></section></article><h4 id="Internal-functions"><a class="docs-heading-anchor" href="#Internal-functions">Internal functions</a><a id="Internal-functions-1"></a><a class="docs-heading-anchor-permalink" href="#Internal-functions" title="Permalink"></a></h4><article class="docstring"><header><a class="docstring-binding" id="Mikrubi.filterext" href="#Mikrubi.filterext"><code>Mikrubi.filterext</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">filterext(dir::AbstractString, extset=nothing) :: Vector{String}</code></pre><p>Find all file names in <code>dir</code> with extensions in <code>extset</code>. When <code>extset</code> is set  to <code>nothing</code> (by default), all extensions are acceptable.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Mikumikunisiteageru/Mikrubi.jl/blob/c0c0148e2c54247a8d57189244738c548da2de24/src/shape.jl#L3-L8">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Mikrubi.goodcolumns" href="#Mikrubi.goodcolumns"><code>Mikrubi.goodcolumns</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">goodcolumns(shptable::AG.IFeatureLayer) :: Dict{String, Vector}</code></pre><p>Find all properties of features in <code>shptable</code> where entries are all unique and  either integers or strings (types whose <code>isequal</code> is well-defined).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Mikumikunisiteageru/Mikrubi.jl/blob/c0c0148e2c54247a8d57189244738c548da2de24/src/shape.jl#L63-L68">source</a></section></article><h3 id="Reading-and-writing-list-file"><a class="docs-heading-anchor" href="#Reading-and-writing-list-file">Reading and writing list file</a><a id="Reading-and-writing-list-file-1"></a><a class="docs-heading-anchor-permalink" href="#Reading-and-writing-list-file" title="Permalink"></a></h3><p>List of occupied counties can be prepared explicitly in Julia as a vector or a set. Meanwhile, it is also possible to read from or write to disk such a list, especially when the list is generated outside Julia.</p><article class="docstring"><header><a class="docstring-binding" id="Mikrubi.readlist" href="#Mikrubi.readlist"><code>Mikrubi.readlist</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">readlist(path::AbstractString) :: Vector</code></pre><p>Read any list of vector from file at <code>path</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Mikumikunisiteageru/Mikrubi.jl/blob/c0c0148e2c54247a8d57189244738c548da2de24/src/core.jl#L159-L163">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Mikrubi.writelist" href="#Mikrubi.writelist"><code>Mikrubi.writelist</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">writelist(path::AbstractString, list::AbstractVector) :: Nothing</code></pre><p>Write any list or vector to file at <code>path</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Mikumikunisiteageru/Mikrubi.jl/blob/c0c0148e2c54247a8d57189244738c548da2de24/src/core.jl#L152-L156">source</a></section></article><h3 id="Reading-and-writing-raster-layers"><a class="docs-heading-anchor" href="#Reading-and-writing-raster-layers">Reading and writing raster layers</a><a id="Reading-and-writing-raster-layers-1"></a><a class="docs-heading-anchor-permalink" href="#Reading-and-writing-raster-layers" title="Permalink"></a></h3><p>Climatic factors are downloaded and stored as raster layers. Mikrubi reads such layers by <a href="#Mikrubi.readlayers"><code>readlayers</code></a>, performs principal component analysis on them and returns the results as layers also. When the output layers need to be kept for future use, they can be written to disk using <a href="#Mikrubi.writelayers"><code>writelayers</code></a>. Moreover, when the predicted distribution of species is organized in raster format, it can be saved likewise using <a href="#Mikrubi.writelayer"><code>writelayer</code></a>.</p><article class="docstring"><header><a class="docstring-binding" id="Mikrubi.readlayers" href="#Mikrubi.readlayers"><code>Mikrubi.readlayers</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">readlayers(filenames::Vector{&lt;:AbstractString}) :: RasterStack
readlayers(dir::AbstractString; extset=nothing) :: RasterStack</code></pre><p>Read all raster layers from the directory <code>dir</code> as a <code>RasterStack</code>. </p><p><code>extset</code> describes possible extensions of raster files (e.g., <code>Set(&quot;.tif&quot;)</code>,  or <code>[&quot;.tiff&quot;]</code>; see also <a href="#Mikrubi.readshape"><code>readshape</code></a>). By setting <code>extset</code> to  <code>nothing</code>, the extension filtering is not processed, i.e., all files are  regarded as raster files. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Mikumikunisiteageru/Mikrubi.jl/blob/c0c0148e2c54247a8d57189244738c548da2de24/src/layer.jl#L92-L102">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Mikrubi.writelayer" href="#Mikrubi.writelayer"><code>Mikrubi.writelayer</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">writelayer(path::AbstractString, layer::Raster) :: Nothing</code></pre><p>Write <code>layer</code> to the disk at <code>path</code>. Alias for <code>GeoArrays.write!</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Mikumikunisiteageru/Mikrubi.jl/blob/c0c0148e2c54247a8d57189244738c548da2de24/src/layer.jl#L112-L116">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Mikrubi.writelayers" href="#Mikrubi.writelayers"><code>Mikrubi.writelayers</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">writelayers(paths::AbstractVector{&lt;:AbstractString}, 
	layers::RasterStack) :: Nothing
writelayers(pathformula::AbstractString, layers::RasterStack) :: Nothing</code></pre><p>Write <code>layers</code> to <code>paths</code> respondingly, or a series of paths generated by the <code>pathformula</code> where an asterisk is used for wildcard and replaced by numbers.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Mikumikunisiteageru/Mikrubi.jl/blob/c0c0148e2c54247a8d57189244738c548da2de24/src/layer.jl#L119-L126">source</a></section></article><h4 id="Internal-functions-2"><a class="docs-heading-anchor" href="#Internal-functions-2">Internal functions</a><a class="docs-heading-anchor-permalink" href="#Internal-functions-2" title="Permalink"></a></h4><p>It is worth mention that when reading layers from a directory, files are sorted according to their names in a manner similar to the sorting order in Windows OS. Please pay extra attention when two parallel raster stacks are fed into <a href="#Mikrubi.makefield"><code>makefield</code></a>. </p><article class="docstring"><header><a class="docstring-binding" id="Mikrubi.sortfilenames!" href="#Mikrubi.sortfilenames!"><code>Mikrubi.sortfilenames!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">sortfilenames!(filenames::AbstractVector{&lt;:AbstractString})</code></pre><p>Sort <code>filenames</code> in place according to the order of the distinctive parts  among them. If all of the distinctive parts are decimal numerals, they are  sorted as integers.</p><p><strong>Examples</strong></p><pre><code class="language-julia hljs">julia&gt; sortfilenames!([&quot;bio_9.tif&quot;, &quot;bio_10.tif&quot;, &quot;bio_1.tif&quot;])
[ Info: 3 files &quot;bio_*.tif&quot; recognized in the directory, where * = 1, 9, 10.
3-element Array{String,1}:
 &quot;bio_1.tif&quot;
 &quot;bio_9.tif&quot;
 &quot;bio_10.tif&quot;

julia&gt; sortfilenames!([&quot;bio_09.tif&quot;, &quot;bio_10.tif&quot;, &quot;bio_01.tif&quot;])
[ Info: 3 files &quot;bio_*.tif&quot; recognized in the directory, where * = 01, 09, 10.
3-element Array{String,1}:
 &quot;bio_01.tif&quot;
 &quot;bio_09.tif&quot;
 &quot;bio_10.tif&quot;</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Mikumikunisiteageru/Mikrubi.jl/blob/c0c0148e2c54247a8d57189244738c548da2de24/src/layer.jl#L40-L63">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Mikrubi.allsame" href="#Mikrubi.allsame"><code>Mikrubi.allsame</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">allsame(a::AbstractVector) :: Bool</code></pre><p>Return <code>true</code> if all elements from <code>a</code> are identical, or otherwise <code>false</code>.  An error is thrown if the vector <code>a</code> is empty.</p><p><strong>Examples</strong></p><pre><code class="language-julia hljs">julia&gt; allsame([1, 1, 2])
false

julia&gt; allsame([1, 1, 1])
true

julia&gt; allsame([1])
true

julia&gt; allsame([])
ERROR: BoundsError: attempt to access 0-element Array{Any,1} at index [1]
Stacktrace:
 [1] getindex at .\array.jl:787 [inlined]
 [2] allsame(::Array{Any,1}) at .\REPL[9]:1
 [3] top-level scope at REPL[20]:1</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Mikumikunisiteageru/Mikrubi.jl/blob/c0c0148e2c54247a8d57189244738c548da2de24/src/layer.jl#L13-L37">source</a></section></article><h3 id="Reading-and-writing-Mikrubi-fields"><a class="docs-heading-anchor" href="#Reading-and-writing-Mikrubi-fields">Reading and writing Mikrubi fields</a><a id="Reading-and-writing-Mikrubi-fields-1"></a><a class="docs-heading-anchor-permalink" href="#Reading-and-writing-Mikrubi-fields" title="Permalink"></a></h3><p><a href="#Mikrubi.MikrubiField"><code>MikrubiField</code></a> is a specially designed type where the environmental information of pixels and their county identifiers are nested. It may be necessary to save (by <a href="#Mikrubi.writefield"><code>writefield</code></a>) and load (by <a href="#Mikrubi.readfield"><code>readfield</code></a>) a Mikrubi field especially when it is used on multiple species.</p><article class="docstring"><header><a class="docstring-binding" id="Mikrubi.readfield" href="#Mikrubi.readfield"><code>Mikrubi.readfield</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">readfield(path::AbstractString) :: MikrubiField</code></pre><p>Read a Mikrubi field from file at <code>path</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Mikumikunisiteageru/Mikrubi.jl/blob/c0c0148e2c54247a8d57189244738c548da2de24/src/core.jl#L90-L94">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Mikrubi.writefield" href="#Mikrubi.writefield"><code>Mikrubi.writefield</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">writefield(path::AbstractString, field::MikrubiField) :: Nothing</code></pre><p>Write a Mikrubi field to file at <code>path</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Mikumikunisiteageru/Mikrubi.jl/blob/c0c0148e2c54247a8d57189244738c548da2de24/src/core.jl#L78-L82">source</a></section></article><h3 id="Reading-and-writing-Mikrubi-models"><a class="docs-heading-anchor" href="#Reading-and-writing-Mikrubi-models">Reading and writing Mikrubi models</a><a id="Reading-and-writing-Mikrubi-models-1"></a><a class="docs-heading-anchor-permalink" href="#Reading-and-writing-Mikrubi-models" title="Permalink"></a></h3><p><a href="#Mikrubi.MikrubiModel"><code>MikrubiModel</code></a> is a struct containing transformation parameters. It can be read from and written to disk using respectively <a href="#Mikrubi.readmodel"><code>readmodel</code></a> and <a href="#Mikrubi.writemodel"><code>writemodel</code></a>. </p><article class="docstring"><header><a class="docstring-binding" id="Mikrubi.readmodel" href="#Mikrubi.readmodel"><code>Mikrubi.readmodel</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">readmodel(path::AbstractString) :: MikrubiModel</code></pre><p>Read a Mikrubi model from file at <code>path</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Mikumikunisiteageru/Mikrubi.jl/blob/c0c0148e2c54247a8d57189244738c548da2de24/src/core.jl#L139-L143">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Mikrubi.writemodel" href="#Mikrubi.writemodel"><code>Mikrubi.writemodel</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">writemodel(path::AbstractString, model::MikrubiModel) :: Nothing</code></pre><p>Write a Mikrubi model to file at <code>path</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Mikumikunisiteageru/Mikrubi.jl/blob/c0c0148e2c54247a8d57189244738c548da2de24/src/core.jl#L131-L135">source</a></section></article><h2 id="Rasterizing-a-shapefile"><a class="docs-heading-anchor" href="#Rasterizing-a-shapefile">Rasterizing a shapefile</a><a id="Rasterizing-a-shapefile-1"></a><a class="docs-heading-anchor-permalink" href="#Rasterizing-a-shapefile" title="Permalink"></a></h2><p>Since v1.3.0, Mikrubi no longer provides its own rasterization routine; the implementation from <a href="https://rafaqz.github.io/Rasters.jl/stable/">Rasters</a> is applied instead. The function <a href="#Mikrubi.rasterize"><code>rasterize</code></a> in Mikrubi integrates the rasterization of multiple geometries. The returned value is of an internal type <a href="#Mikrubi.CtPixels"><code>Mikrubi.CtPixels</code></a>.</p><article class="docstring"><header><a class="docstring-binding" id="Mikrubi.rasterize" href="#Mikrubi.rasterize"><code>Mikrubi.rasterize</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">rasterize(geoms, layer::Raster) :: CtPixels
rasterize(shptable::AG.IFeatureLayer, layer::Raster) :: CtPixels</code></pre><p>For a collection of (multi)polygons, rasterize each of them and write the  results in a CtPixels.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Mikumikunisiteageru/Mikrubi.jl/blob/c0c0148e2c54247a8d57189244738c548da2de24/src/rasterize.jl#L93-L99">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Mikrubi.CtPixels" href="#Mikrubi.CtPixels"><code>Mikrubi.CtPixels</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">CtPixels

CtPixels(indices::Raster{Int})</code></pre><p>Collector for county-specific rasterization results, whose <code>list</code> contains  county-pixel tuples. Can only be instantiated from an index raster  (see <a href="#Mikrubi.indicate"><code>indicate</code></a>).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Mikumikunisiteageru/Mikrubi.jl/blob/c0c0148e2c54247a8d57189244738c548da2de24/src/rasterize.jl#L3-L11">source</a></section></article><h4 id="Internal-functions-3"><a class="docs-heading-anchor" href="#Internal-functions-3">Internal functions</a><a class="docs-heading-anchor-permalink" href="#Internal-functions-3" title="Permalink"></a></h4><article class="docstring"><header><a class="docstring-binding" id="Mikrubi.getpixels" href="#Mikrubi.getpixels"><code>Mikrubi.getpixels</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">getpixels(ctpixels::CtPixels) :: Vector{Int}</code></pre><p>Get pixel indices from <code>ctpixels</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Mikumikunisiteageru/Mikrubi.jl/blob/c0c0148e2c54247a8d57189244738c548da2de24/src/rasterize.jl#L20-L24">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Mikrubi.getcounties" href="#Mikrubi.getcounties"><code>Mikrubi.getcounties</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">getcounties(ctpixels::CtPixels) :: Vector{Int}</code></pre><p>Get county indices from <code>ctpixels</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Mikumikunisiteageru/Mikrubi.jl/blob/c0c0148e2c54247a8d57189244738c548da2de24/src/rasterize.jl#L27-L31">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Mikrubi.getpixel" href="#Mikrubi.getpixel"><code>Mikrubi.getpixel</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">getpixel(ctpixels::CtPixels, i::Int) :: Int</code></pre><p>Get the pixel index of the <code>i</code>-th county-pixel tuple in <code>ctpixels</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Mikumikunisiteageru/Mikrubi.jl/blob/c0c0148e2c54247a8d57189244738c548da2de24/src/rasterize.jl#L34-L38">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Mikrubi.getcounty" href="#Mikrubi.getcounty"><code>Mikrubi.getcounty</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">getcounty(ctpixels::CtPixels, i::Int) :: Int</code></pre><p>Get the county index of the <code>i</code>-th county-pixel tuple in <code>ctpixels</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Mikumikunisiteageru/Mikrubi.jl/blob/c0c0148e2c54247a8d57189244738c548da2de24/src/rasterize.jl#L41-L45">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Mikrubi.indicate" href="#Mikrubi.indicate"><code>Mikrubi.indicate</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">indicate(layer::Raster) :: Raster{Int}</code></pre><p>Build an index raster <code>indices</code> from <code>layer</code>. The value of an array element in  <code>indices</code> is either (1) <code>0</code> for missing, if the corresponding element in  <code>layer</code> is missing; or (2) the integer index of the array element, otherwise. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Mikumikunisiteageru/Mikrubi.jl/blob/c0c0148e2c54247a8d57189244738c548da2de24/src/rasterize.jl#L48-L54">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Mikrubi.register!" href="#Mikrubi.register!"><code>Mikrubi.register!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">register!(ctpixels::CtPixels, ct::Int, pixel::Int) :: Int</code></pre><p>Push a county-pixel tuple into <code>ctpixels</code>, if <code>pixel</code> is not zero. For  convenience, the value of <code>pixel</code> is returned. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Mikumikunisiteageru/Mikrubi.jl/blob/c0c0148e2c54247a8d57189244738c548da2de24/src/rasterize.jl#L62-L67">source</a></section><section><div><pre><code class="nohighlight hljs">register!(ctpixels::CtPixels, ct::Int) :: Function</code></pre><p>Create a function that accepts a <code>pixel</code>, pushes the county-pixel tuple into  <code>ctpixels</code>, and finally returns the value of <code>pixel</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Mikumikunisiteageru/Mikrubi.jl/blob/c0c0148e2c54247a8d57189244738c548da2de24/src/rasterize.jl#L73-L78">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Mikrubi.ispoly" href="#Mikrubi.ispoly"><code>Mikrubi.ispoly</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">ispoly(geom) :: Bool</code></pre><p>Check if <code>geom</code> is a polygon or a multipolygon.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Mikumikunisiteageru/Mikrubi.jl/blob/c0c0148e2c54247a8d57189244738c548da2de24/src/rasterize.jl#L82-L86">source</a></section></article><h2 id="makefield"><a class="docs-heading-anchor" href="#makefield">Processing the raster layers</a><a id="makefield-1"></a><a class="docs-heading-anchor-permalink" href="#makefield" title="Permalink"></a></h2><p>In Mikrubi, climatic factors after being read in typically undergo some processing steps together with shapefile inside the function <a href="#Mikrubi.makefield"><code>makefield</code></a>, which returns a Mikrubi field and a stack of extracted components in raster layers. The two outputs can be used for training and prediction.</p><p>Sometimes it is also required to apply a model to another circumstance (different time or different space), in which case another series of parallel climatic factor layers need to be processed in exactly the same way as those used to generate the Mikrubi field (so that their climatic meanings are the same). Such layers need to be put in the third place in the input argument list for <a href="#Mikrubi.makefield"><code>makefield</code></a>, and those parallelly extracted components are returned in the third place in output as well.</p><article class="docstring"><header><a class="docstring-binding" id="Mikrubi.makefield" href="#Mikrubi.makefield"><code>Mikrubi.makefield</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">makefield(layers::RasterStack, ctpixels::CtPixels; 
	rabsthres=0.8, nprincomp=3) :: Tuple{MikrubiField, RasterStack}
makefield(layers::RasterStack, ctpixels::CtPixels, 
	players::RasterStack; rabsthres=0.8, nprincomp=3)
		:: Tuple{MikrubiField, RasterStack, RasterStack}
makefield(layers::RasterStack, shptable; rabsthres=0.8, nprincomp=3)
	:: Tuple{MikrubiField, RasterStack}
makefield(layers::RasterStack, shptable, players::RasterStack; 
	rabsthres=0.8, nprincomp=3)
		:: Tuple{MikrubiField, RasterStack, RasterStack}</code></pre><p>Create a <code>MikrubiField</code> as well as processed variable layers from <code>layers</code>   and <code>shptable</code> or <code>ctpixels</code>, by </p><ol><li>(rasterizing the <code>shptable</code> to <code>ctpixels</code> using <code>rasterize</code>,) </li><li>masking the <code>layers</code> with <code>ctpixels</code> (using <code>Mikrubi.masklayers!</code>), </li><li>extracting non-missing pixels from <code>layers</code> (using <code>Mikrubi.extractlayers</code>),</li><li>selecting less correlated variables (using <code>Mikrubi.selectvars</code>), and </li><li>doing the principal component analysis (using <code>Mikrubi.princompvars</code>).</li></ol><p><strong>Optional keyword arguments</strong></p><ul><li><code>rabsthres</code>: threshold of collinearity.</li></ul><p>Absolute value of Pearson correlation efficient greater than this threshold  is identified as collinearity and the two variables are thus incompatible. </p><ul><li><code>nprincomp</code>: expected number of principal components of the variables.</li></ul><p><strong>Notes about <code>players</code></strong></p><p>When <code>players</code> is present in the argument list, raster layers it contains  experience the same process including subsetting, selecting, and taking  principal components, and results are packed and returned in the third place.  User must assure that <code>players</code> has the same length as <code>layers</code>, and  their elements are corresponding in order. This would be useful when the  prediction is in another geographic range or at another time.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Mikumikunisiteageru/Mikrubi.jl/blob/c0c0148e2c54247a8d57189244738c548da2de24/src/layer.jl#L374-L409">source</a></section></article><h4 id="Internal-functions-4"><a class="docs-heading-anchor" href="#Internal-functions-4">Internal functions</a><a class="docs-heading-anchor-permalink" href="#Internal-functions-4" title="Permalink"></a></h4><article class="docstring"><header><a class="docstring-binding" id="Mikrubi.colmatrix" href="#Mikrubi.colmatrix"><code>Mikrubi.colmatrix</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">colmatrix(vector::AbstractVector) :: AbstractMatrix
colmatrix(matrix::AbstractMatrix) :: AbstractMatrix</code></pre><p>Return a one-column matrix if the argument is a vector, or the matrix itself  if the argument is already a matrix.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Mikumikunisiteageru/Mikrubi.jl/blob/c0c0148e2c54247a8d57189244738c548da2de24/src/layer.jl#L3-L9">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Mikrubi.masklayers!" href="#Mikrubi.masklayers!"><code>Mikrubi.masklayers!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">masklayers!(layers::RasterStack, ctpixels::CtPixels) :: RasterStack</code></pre><p>Mask the <code>layers</code> in a way that only pixels present in <code>ctpixels</code> are kept,  while all other uncovered pixels are set to a missing value.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Mikumikunisiteageru/Mikrubi.jl/blob/c0c0148e2c54247a8d57189244738c548da2de24/src/layer.jl#L144-L149">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Mikrubi.extractlayers" href="#Mikrubi.extractlayers"><code>Mikrubi.extractlayers</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">extractlayers(layers::RasterStack) :: Tuple{Matrix, Vector{Int}}</code></pre><p>Extract the non-missing pixels from <code>layers</code>, and combine them into a matrix,  whose rows representing pixels and columns representing variables.</p><p><code>extractlayers</code> is the inverse function of <a href="#Mikrubi.makelayers"><code>makelayers</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Mikumikunisiteageru/Mikrubi.jl/blob/c0c0148e2c54247a8d57189244738c548da2de24/src/layer.jl#L159-L166">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Mikrubi.emptylayer!" href="#Mikrubi.emptylayer!"><code>Mikrubi.emptylayer!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">emptylayer!(grid::Raster) :: Raster</code></pre><p>Fill the <code>grid</code> with missing values in place.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Mikumikunisiteageru/Mikrubi.jl/blob/c0c0148e2c54247a8d57189244738c548da2de24/src/layer.jl#L172-L176">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Mikrubi.emptylayer" href="#Mikrubi.emptylayer"><code>Mikrubi.emptylayer</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">emptylayer(grid::Raster) :: Raster</code></pre><p>Create a new <code>Raster</code> full of missing values from the shape of <code>grid</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Mikumikunisiteageru/Mikrubi.jl/blob/c0c0148e2c54247a8d57189244738c548da2de24/src/layer.jl#L179-L183">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Mikrubi.emptylayers" href="#Mikrubi.emptylayers"><code>Mikrubi.emptylayers</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">emptylayers(grid::Raster, m::Int) :: RasterStack</code></pre><p>Create a <code>RasterStack</code> with <code>m</code> empty <code>Raster</code>s (full of missing values) from  the shape of <code>grid</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Mikumikunisiteageru/Mikrubi.jl/blob/c0c0148e2c54247a8d57189244738c548da2de24/src/layer.jl#L186-L191">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Mikrubi.makelayer" href="#Mikrubi.makelayer"><code>Mikrubi.makelayer</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">makelayer(vector::AbstractVector, idx::AbstractVector, grid::Raster)</code></pre><p>Make a <code>Raster</code> from the <code>grid</code> and values in <code>vector</code>. </p><p>For making a <code>RasterStack</code> from a matrix, see <a href="#Mikrubi.makelayers"><code>makelayers</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Mikumikunisiteageru/Mikrubi.jl/blob/c0c0148e2c54247a8d57189244738c548da2de24/src/layer.jl#L216-L222">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Mikrubi.makelayers" href="#Mikrubi.makelayers"><code>Mikrubi.makelayers</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">makelayers(matrix::AbstractMatrix, idx::AbstractVector, grid::Raster) 
	:: RasterStack</code></pre><p>Make a <code>RasterStack</code> from the <code>grid</code> and values in columns of <code>matrix</code>.</p><p>For making a <code>Raster</code> from a column vector, see <a href="#Mikrubi.makelayer"><code>makelayer</code></a>.</p><p><code>makelayers</code> is the inverse function of <a href="#Mikrubi.extractlayers"><code>extractlayers</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Mikumikunisiteageru/Mikrubi.jl/blob/c0c0148e2c54247a8d57189244738c548da2de24/src/layer.jl#L195-L204">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Mikrubi.dftraverse!" href="#Mikrubi.dftraverse!"><code>Mikrubi.dftraverse!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">dftraverse!(beststate, bestscore, state, score, depth, maxdepth, 
	incompat, scoremat) :: Nothing</code></pre><p>Find the index combination that</p><ul><li>firstly containing as many indices as possible, and</li><li>secondly with the lowest pairwise sum from submatrix of <code>scoremat</code>,</li></ul><p>such that no indices <code>i</code> and <code>j</code> coexist as long as <code>incompat[i][j] == true</code>.</p><p>The result is stored as the only element of <code>beststate</code>, with its score decided by the two criteria above stored as the only element of <code>bestscore</code>.</p><p><strong>Example</strong></p><pre><code class="language-julia hljs">julia&gt; beststate = Vector(undef, 1);

julia&gt; bestscore = [(0, 0.0)];

julia&gt; dftraverse!(beststate, bestscore, Int[], (0, 0.0), 1, 3,
           Bool[0 0 1; 0 0 0; 1 0 0],
           [0.0 0.6 0.3; 0.6 0.0 0.9; 0.3 0.9 0.0]);

julia&gt; beststate
1-element Array{Any,1}:
 [1, 2]

julia&gt; bestscore
1-element Array{Tuple{Int64,Float64},1}:
 (2, -0.6)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Mikumikunisiteageru/Mikrubi.jl/blob/c0c0148e2c54247a8d57189244738c548da2de24/src/layer.jl#L226-L256">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Mikrubi.selectvars" href="#Mikrubi.selectvars"><code>Mikrubi.selectvars</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">selectvars(matrix::Matrix, rabsthres=0.8) :: Vector{Int}</code></pre><p>Select as many variables as possible from <code>matrix</code> such that no pairwise Pearson coefficient among them exceeds <code>rabsthres</code> and their sum is minimal.</p><p><strong>Example</strong></p><pre><code class="language-julia hljs">julia&gt; selectvars([1. 4. 7.; 2. 5. 8.; 3. 9. 27.], rabsthres=0.9)
2-element Array{Int64,1}:
 1
 3</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Mikumikunisiteageru/Mikrubi.jl/blob/c0c0148e2c54247a8d57189244738c548da2de24/src/layer.jl#L275-L288">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Mikrubi.princompvars" href="#Mikrubi.princompvars"><code>Mikrubi.princompvars</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">princompvars(smatrix::Matrix; nprincomp=3) :: Tuple{Vector, Matrix}</code></pre><p>Perform principal component analysis on <code>smatrix</code> whose columns represents variables, and combines the <code>nprincomp</code> principal components into a matrix, and returns the result matrix as well as the affine transformation <code>(colmean, projwstd)</code>, such that the result matrix == <code>(smatrix .- colmean) * projwstd</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Mikumikunisiteageru/Mikrubi.jl/blob/c0c0148e2c54247a8d57189244738c548da2de24/src/layer.jl#L311-L319">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Mikrubi.DimLower" href="#Mikrubi.DimLower"><code>Mikrubi.DimLower</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">DimLower

DimLower()</code></pre><p>A container for transformation used in <code>makefield</code>, working as a function. If  it is new (<code>new=true</code>), the parameters (<code>colid</code>, <code>colmean</code>, and <code>projwstd</code>)  are computed when it is applied on a <code>RasterStack</code>. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Mikumikunisiteageru/Mikrubi.jl/blob/c0c0148e2c54247a8d57189244738c548da2de24/src/layer.jl#L345-L353">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Mikrubi.dimpoints" href="#Mikrubi.dimpoints"><code>Mikrubi.dimpoints</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">dimpoints(grid::Raster) :: DimPoints</code></pre><p>Create a <code>DimensionalData.DimPoints</code> from <code>grid</code> after shifting all its  dimension loci to <code>Center()</code>. Similar to <code>GeoArrays.coords</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Mikumikunisiteageru/Mikrubi.jl/blob/c0c0148e2c54247a8d57189244738c548da2de24/src/layer.jl#L441-L446">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Mikrubi.centercoords" href="#Mikrubi.centercoords"><code>Mikrubi.centercoords</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">centercoords(dp::DimPoints, ci::CartesianIndices, idx::Int) 
	:: Tuple{AbstractFloat, AbstractFloat}</code></pre><p>Get center coordinates of a grid cell indexed by <code>idx</code> in a <code>Raster</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Mikumikunisiteageru/Mikrubi.jl/blob/c0c0148e2c54247a8d57189244738c548da2de24/src/layer.jl#L454-L459">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Mikrubi.buildfield" href="#Mikrubi.buildfield"><code>Mikrubi.buildfield</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">buildfield(ctpixels::CtPixels, idx::Vector, 
	projmat::Matrix, grid::Raster) :: MikrubiField</code></pre><p>Construct a <code>MikrubiField</code> from <code>ctpixels</code>, <code>idx</code>, <code>projmat</code>, and <code>grid</code>. Used in  <a href="#Mikrubi.makefield"><code>makefield</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Mikumikunisiteageru/Mikrubi.jl/blob/c0c0148e2c54247a8d57189244738c548da2de24/src/layer.jl#L468-L474">source</a></section></article><h2 id="The-Mikrubi-core"><a class="docs-heading-anchor" href="#The-Mikrubi-core">The Mikrubi core</a><a id="The-Mikrubi-core-1"></a><a class="docs-heading-anchor-permalink" href="#The-Mikrubi-core" title="Permalink"></a></h2><p>Two specially designed structs are involved in the core of Mikrubi.</p><h3 id="Mikrubi-field"><a class="docs-heading-anchor" href="#Mikrubi-field">Mikrubi field</a><a id="Mikrubi-field-1"></a><a class="docs-heading-anchor-permalink" href="#Mikrubi-field" title="Permalink"></a></h3><p><a href="#Mikrubi.MikrubiField"><code>MikrubiField</code></a> is a struct containing mainly three types of information of pixels/points, that is, which counties they belong to (<code>ctids</code>), their geographic coordinates (<code>locs</code>), and their environmental coordinates (<code>vars</code>), with also some derived assistant attributes, such as geographic dimensionality (usually <code>2</code>) and environmental dimensionality (for example, <code>3</code>).</p><p><a href="#Mikrubi.MikrubiField"><code>MikrubiField</code></a> can be obtained in three ways: as first output argument of <a href="#makefield"><code>makefield</code></a>, read from disk, or constructed directly from the three required attributes (this may be useful for simulation analysis). </p><article class="docstring"><header><a class="docstring-binding" id="Mikrubi.MikrubiField" href="#Mikrubi.MikrubiField"><code>Mikrubi.MikrubiField</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">MikrubiField{T, U &lt;: Real, V &lt;: AbstractFloat}

MikrubiField(ctids, locs, vars)</code></pre><p>Construct a Mikrubi field containing a number of pixels or points, using the arguments which should always have the same number of rows</p><ul><li><code>ctids::Vector</code>: a vector containing the county identifiers</li><li><code>locs::Array{&lt;:Real}</code>: an array of geographic coordinates</li><li><code>vars::Matrix{&lt;:AbstractFloat}</code>: an array of environmental coordinates</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Mikumikunisiteageru/Mikrubi.jl/blob/c0c0148e2c54247a8d57189244738c548da2de24/src/core.jl#L22-L32">source</a></section></article><h3 id="Mikrubi-model"><a class="docs-heading-anchor" href="#Mikrubi-model">Mikrubi model</a><a id="Mikrubi-model-1"></a><a class="docs-heading-anchor-permalink" href="#Mikrubi-model" title="Permalink"></a></h3><p><a href="#Mikrubi.MikrubiModel"><code>MikrubiModel</code></a> contains the environmental dimensionality and the model parameters to define a positive-definite quadratic mapping from environmental space to a real number axis. </p><p>Like <a href="#Mikrubi.MikrubiField"><code>MikrubiField</code></a>, <a href="#Mikrubi.MikrubiField"><code>MikrubiField</code></a> can be obtained in three ways: as output argument of <a href="#fitfuncm"><code>fit</code></a>, read from disk, or constructed directly from attributes. An example of obtaining Mikrubi field and Mikrubi model from constructors are available in <code>examples/onedimsim/sim.jl</code>.</p><article class="docstring"><header><a class="docstring-binding" id="Mikrubi.MikrubiModel" href="#Mikrubi.MikrubiModel"><code>Mikrubi.MikrubiModel</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">MikrubiModel{V &lt;: AbstractFloat}

MikrubiModel(dvar::Int, params::Vector{&lt;:AbstractFloat})</code></pre><p>Construct a Mikrubi Model from a dimensionality <code>dvar</code> and a parameter vector <code>params</code>. The equation must hold for <code>dvar2dparam(dvar) == length(params)</code>.</p><p>Mikrubi Models can be obtained from the function <code>fit</code>, and can be used in the function <code>predict</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Mikumikunisiteageru/Mikrubi.jl/blob/c0c0148e2c54247a8d57189244738c548da2de24/src/core.jl#L107-L117">source</a></section></article><h3 id="fitfuncm"><a class="docs-heading-anchor" href="#fitfuncm">Fitting a Mikrubi model</a><a id="fitfuncm-1"></a><a class="docs-heading-anchor-permalink" href="#fitfuncm" title="Permalink"></a></h3><p>When a Mikrubi field as well as occurrence data in county and/or in coordinates are ready, they can be used to train a Mikrubi model by function <a href="#Mikrubi.fit"><code>fit</code></a> (county data at <code>counties</code>, required; coordinates at <code>coords</code>, optional). Result is output as a <a href="#Mikrubi.MikrubiModel"><code>MikrubiModel</code></a>.</p><article class="docstring"><header><a class="docstring-binding" id="Mikrubi.fit" href="#Mikrubi.fit"><code>Mikrubi.fit</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">fit(field::MikrubiField, counties, coords=zeros(0, 0); 
	optresult=[], iterations=3_000_000, kwargs...) :: MikrubiModel</code></pre><p>Numerically find the Mikrubi model maximizing the likelihood that the occupied  counties as well as the occupied coordinates are sampled in the given Mikrubi  field. The optimization result is stored in the container <code>optresult</code> for  debugging.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Mikumikunisiteageru/Mikrubi.jl/blob/c0c0148e2c54247a8d57189244738c548da2de24/src/core.jl#L271-L279">source</a></section></article><h3 id="Predicting-from-a-Mikrubi-model"><a class="docs-heading-anchor" href="#Predicting-from-a-Mikrubi-model">Predicting from a Mikrubi model</a><a id="Predicting-from-a-Mikrubi-model-1"></a><a class="docs-heading-anchor-permalink" href="#Predicting-from-a-Mikrubi-model" title="Permalink"></a></h3><p>A Mikrubi model can be applied by function <a href="#Mikrubi.predict"><code>predict</code></a> to a matrix with its columns corresponding to extracted variables, a stack of extracted layers, or a Mikrubi field. </p><ul><li>When input argument is a matrix, output argument is a column vector denoting the probability of presence in pixels/points related to rows in the matrix.</li><li>When input argument is a stack of layers, output argument is a single layer denoting the probability of presence.</li><li>When input argument is a Mikrubi field, output argument is a <code>Dict</code> which maps every county identifier to probability of presence at pixels inside the county, see also <a href="#Mikrubi.predictcounty"><code>predictcounty</code></a>.</li></ul><article class="docstring"><header><a class="docstring-binding" id="Mikrubi.predict" href="#Mikrubi.predict"><code>Mikrubi.predict</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">predict(matrix::AbstractMatrix, model::MikrubiModel) :: Vector
predict(layers::RasterStack, model::MikrubiModel) :: Raster
predict(field::MikrubiField, model::MikrubiModel) 
	:: Dict{&lt;:Any, &lt;:Vector{&lt;:Tuple{Vector{&lt;:Real}, AbstractFloat}}}</code></pre><p>Predict the probability of presence according to processed climatic factors  (<code>matrix</code> / <code>layers</code>) or on the Mikrubi <code>field</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Mikumikunisiteageru/Mikrubi.jl/blob/c0c0148e2c54247a8d57189244738c548da2de24/src/core.jl#L301-L309">source</a></section></article><p>When distribution probability within only one county is concerned, <a href="#Mikrubi.predictcounty"><code>predictcounty</code></a> returns probability of presence at all pixels that constitute the county in descending order. Therefore, the first element represents the most likely occupied pixel of a county.</p><article class="docstring"><header><a class="docstring-binding" id="Mikrubi.predictcounty" href="#Mikrubi.predictcounty"><code>Mikrubi.predictcounty</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">predictcounty(field::MikrubiField, model::MikrubiModel, county) 
	:: Vector{&lt;:Tuple{Vector{&lt;:Real}, AbstractFloat}}</code></pre><p>Return the geographic coordinates of pixels in the county sorted by the likeliness of being occupied.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Mikumikunisiteageru/Mikrubi.jl/blob/c0c0148e2c54247a8d57189244738c548da2de24/src/core.jl#L325-L331">source</a></section></article><p>It is also possible to obtain the overall probability that every county is occupied by the function <a href="#Mikrubi.probcounties"><code>probcounties</code></a>.</p><article class="docstring"><header><a class="docstring-binding" id="Mikrubi.probcounties" href="#Mikrubi.probcounties"><code>Mikrubi.probcounties</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">probcounties(field::MikrubiField{T, U, V}, model::MikrubiModel{V}) 
	:: Dict{&lt;:Any, &lt;:AbstractFloat}</code></pre><p>Compute the probability for every county to be occupied in the <code>field</code>. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Mikumikunisiteageru/Mikrubi.jl/blob/c0c0148e2c54247a8d57189244738c548da2de24/src/core.jl#L350-L355">source</a></section></article><h3 id="Sampling-counties-in-a-Mikrubi-field"><a class="docs-heading-anchor" href="#Sampling-counties-in-a-Mikrubi-field">Sampling counties in a Mikrubi field</a><a id="Sampling-counties-in-a-Mikrubi-field-1"></a><a class="docs-heading-anchor-permalink" href="#Sampling-counties-in-a-Mikrubi-field" title="Permalink"></a></h3><p>For simulation analysis, sometimes it is required to sample a set of counties from a Mikrubi field and a Mikrubi model. <a href="#Mikrubi.samplecounties"><code>samplecounties</code></a> does the trick.</p><article class="docstring"><header><a class="docstring-binding" id="Mikrubi.samplecounties" href="#Mikrubi.samplecounties"><code>Mikrubi.samplecounties</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">samplecounties(field::MikrubiField, model::MikrubiModel) :: Vector{Any}</code></pre><p>Sample counties according to their probability of being occupied.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Mikumikunisiteageru/Mikrubi.jl/blob/c0c0148e2c54247a8d57189244738c548da2de24/src/core.jl#L371-L375">source</a></section></article><h3 id="Detecting-overfitting"><a class="docs-heading-anchor" href="#Detecting-overfitting">Detecting overfitting</a><a id="Detecting-overfitting-1"></a><a class="docs-heading-anchor-permalink" href="#Detecting-overfitting" title="Permalink"></a></h3><p>Overfitting can be detected with the Lipschitz constant, the (logarithmic) maximum gradient (in norm) of the probability of presence in environmental space.</p><article class="docstring"><header><a class="docstring-binding" id="Mikrubi.lipschitz" href="#Mikrubi.lipschitz"><code>Mikrubi.lipschitz</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">lipschitz(model::MikrubiModel, field::MikrubiField; wholespace=false) 
	:: AbstractFloat</code></pre><p>Calculate the maximum gradient (in norm) of the probability of presence over  the <code>field</code>. When <code>wholespace=false</code> (default), the maximum is taken among the  points contained in <code>field</code>; otherwise it is taken around the whole space.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Mikumikunisiteageru/Mikrubi.jl/blob/c0c0148e2c54247a8d57189244738c548da2de24/src/core.jl#L408-L415">source</a></section></article><h4 id="Internal-functions-5"><a class="docs-heading-anchor" href="#Internal-functions-5">Internal functions</a><a class="docs-heading-anchor-permalink" href="#Internal-functions-5" title="Permalink"></a></h4><article class="docstring"><header><a class="docstring-binding" id="Mikrubi.dvar2dparam" href="#Mikrubi.dvar2dparam"><code>Mikrubi.dvar2dparam</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">dvar2dparam(dvar::Int) :: Int</code></pre><p>Convert dimensionality of an environmental space to the dimensionality of the induced parameter space, i.e., compute the degrees of freedom for  positive-definite quadratic functions mapping a <code>dvar</code>-dimensional linear space into real numbers.</p><p><strong>Examples</strong></p><pre><code class="language-julia hljs">julia&gt; dvar2dparam(1)
3

julia&gt; dvar2dparam(3)
10</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Mikumikunisiteageru/Mikrubi.jl/blob/c0c0148e2c54247a8d57189244738c548da2de24/src/core.jl#L3-L19">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Mikrubi.decomparams" href="#Mikrubi.decomparams"><code>Mikrubi.decomparams</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">decomparams(p::AbstractVector, d::Int) :: Tuple{Matrix, Vector, Any}
decomparams(model::MikrubiModel) :: Tuple{Matrix, Vector, Any}</code></pre><p>Return parameter decomposition <code>At</code>, <code>b</code>, <code>c</code>, where </p><ul><li><code>At</code> is a lower triangular matrix of size <code>(d, d)</code>,</li><li><code>b</code> is a column vector of size <code>d</code>, and</li><li><code>c</code> is a scalar.</li></ul><p>WARNING: The vector <code>p</code> must have length <code>dvar2dparam(d)</code>.</p><p><strong>Example</strong></p><pre><code class="language-julia hljs">julia&gt; decomparams(collect(1:10), 3)
([1 0 0; 2 3 0; 4 5 6], [7, 8, 9], 10)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Mikumikunisiteageru/Mikrubi.jl/blob/c0c0148e2c54247a8d57189244738c548da2de24/src/core.jl#L166-L182">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Mikrubi.pabsence" href="#Mikrubi.pabsence"><code>Mikrubi.pabsence</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">pabsence(vars::AbstractMatrix, params::AbstractVector) :: Logistic
pabsence(field::MikrubiField, params::AbstractVector) :: Logistic</code></pre><p>Compute the probability of absence at pixels given <code>vars</code>/<code>field</code> and <code>params</code>.	</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Mikumikunisiteageru/Mikrubi.jl/blob/c0c0148e2c54247a8d57189244738c548da2de24/src/core.jl#L195-L200">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Mikrubi.ppresence" href="#Mikrubi.ppresence"><code>Mikrubi.ppresence</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">ppresence(vars::AbstractMatrix, params::AbstractVector) :: Logistic
ppresence(field::MikrubiField, params::AbstractVector) :: Logistic</code></pre><p>Compute the probability of presence at pixels given <code>vars</code>/<code>field</code> and <code>params</code>.	</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Mikumikunisiteageru/Mikrubi.jl/blob/c0c0148e2c54247a8d57189244738c548da2de24/src/core.jl#L208-L213">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Mikrubi.mlogL" href="#Mikrubi.mlogL"><code>Mikrubi.mlogL</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">mlogL(field::MikrubiField, counties, params::AbstractVector)
	:: AbstractFloat
mlogL(vars::AbstractMatrix, params::AbstractVector) :: AbstractFloat</code></pre><p>Compute the opposite log-likelihood that the occupied counties or occupied  coordinates are sampled. The opposite is taken for optimization.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Mikumikunisiteageru/Mikrubi.jl/blob/c0c0148e2c54247a8d57189244738c548da2de24/src/core.jl#L219-L226">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Mikrubi.probpixels" href="#Mikrubi.probpixels"><code>Mikrubi.probpixels</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">probpixels(field::MikrubiField, model::MikrubiModel) 
	:: Vector{&lt;:AbstractFloat}</code></pre><p>Compute the probability for every pixel to be occupied in the <code>field</code>. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Mikumikunisiteageru/Mikrubi.jl/blob/c0c0148e2c54247a8d57189244738c548da2de24/src/core.jl#L341-L346">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Mikrubi.findnearest" href="#Mikrubi.findnearest"><code>Mikrubi.findnearest</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">findnearest(loc::AbstractVecOrMat{&lt;:Real}, field::MikrubiField) :: Int</code></pre><p>Return the row index in <code>field.locs</code> which is the nearest to the given  coordinates.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Mikumikunisiteageru/Mikrubi.jl/blob/c0c0148e2c54247a8d57189244738c548da2de24/src/core.jl#L241-L246">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Mikrubi.findnearests" href="#Mikrubi.findnearests"><code>Mikrubi.findnearests</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">findnearests(loc::AbstractVector{&lt;:AbstractVecOrMat}, field::MikrubiField) 
	:: Vector{Int}
findnearests(loc::AbstractMatrix{&lt;:Real}, field::MikrubiField) 
	:: Vector{Int}</code></pre><p>Return the row indices in <code>field.locs</code> which are the nearest to each of the  given coordinates. Duplicate results are reduced to one.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Mikumikunisiteageru/Mikrubi.jl/blob/c0c0148e2c54247a8d57189244738c548da2de24/src/core.jl#L257-L265">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Mikrubi.loglipschitz" href="#Mikrubi.loglipschitz"><code>Mikrubi.loglipschitz</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">loglipschitz(model::MikrubiModel, field::MikrubiField; wholespace=false) 
	:: AbstractFloat</code></pre><p>Calculate the (logarithmic) maximum gradient (in norm) of the probability of  presence over the <code>field</code>. When <code>wholespace=false</code> (default), the maximum is  taken among the points contained in <code>field</code>; otherwise it is taken around the  whole space.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Mikumikunisiteageru/Mikrubi.jl/blob/c0c0148e2c54247a8d57189244738c548da2de24/src/core.jl#L382-L390">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Mikrubi.textwrap" href="#Mikrubi.textwrap"><code>Mikrubi.textwrap</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">textwrap(str::AbstractString) :: String</code></pre><p>Gobble all linefeeds (&quot;<code>\n</code>&quot;) inside <code>str</code> and replaces them with spaces (&quot;<code></code>&quot;), so long strings can be wrapped to multiple lines in the codes, like  the Python package &quot;textwrap&quot;. See also <a href="@ref"><code>tw</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Mikumikunisiteageru/Mikrubi.jl/blob/c0c0148e2c54247a8d57189244738c548da2de24/src/Mikrubi.jl#L38-L44">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Mikrubi.@tw_str" href="#Mikrubi.@tw_str"><code>Mikrubi.@tw_str</code></a> — <span class="docstring-category">Macro</span></header><section><div><pre><code class="language-julia hljs">@tw_str :: String</code></pre><p>Macro version of <a href="#Mikrubi.textwrap"><code>textwrap</code></a>, without interpolation and unescaping.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Mikumikunisiteageru/Mikrubi.jl/blob/c0c0148e2c54247a8d57189244738c548da2de24/src/Mikrubi.jl#L47-L51">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../">« Home</a><a class="docs-footer-nextpage" href="../graphics/">Graphics »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.24 on <span class="colophon-date" title="Thursday 1 June 2023 14:36">Thursday 1 June 2023</span>. Using Julia version 1.8.5.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
