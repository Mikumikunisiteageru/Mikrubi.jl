var documenterSearchIndex = {"docs":
[{"location":"manual/#Manual","page":"Manual","title":"Manual","text":"","category":"section"},{"location":"manual/","page":"Manual","title":"Manual","text":"Pages = [\"manual.md\"]\nDepth = 3","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"Module = Mikrubi","category":"page"},{"location":"manual/#Reading-and-writing","page":"Manual","title":"Reading and writing","text":"","category":"section"},{"location":"manual/#Reading-and-searching-shapefile","page":"Manual","title":"Reading and searching shapefile","text":"","category":"section"},{"location":"manual/","page":"Manual","title":"Manual","text":"Since shape files are always read instead of written in this application, only the reading function readshape is provided. ","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"readshape","category":"page"},{"location":"manual/#Mikrubi.readshape","page":"Manual","title":"Mikrubi.readshape","text":"readshape(path::AbstractString, index::Int=-1; \n\textset = [\".shp\", \".geojson\", \".gpkg\"]) :: AG.IFeatureLayer\n\nRead a shape file located at path. If path refers to a file, the file is  directly read; otherwise, if path refers to a directory, a random shape file  inside is read. \n\nextset describes possible extensions of shape files (see also  readlayers). By setting extset to nothing, the extension  filtering is not processed, i.e., all files are regarded as shape files.  extset is indifferent when path refers to a file. \n\nThe shape file should contain a dataset. When the dataset consists of multiple  layers, index indicates which data layer should be returned. \n\n\n\n\n\n","category":"function"},{"location":"manual/","page":"Manual","title":"Manual","text":"The function lookup is useful when some attribute (e.g. name or code) of a county is known and the row number of the county in a shapefile is wanted (row number may act as identifiers in the list of occupied counties, see the syntax of fit). ","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"lookup","category":"page"},{"location":"manual/#Mikrubi.lookup","page":"Manual","title":"Mikrubi.lookup","text":"lookup(shptable::AG.IFeatureLayer, \n\tcolumn::Union{AbstractString, Symbol}, entry)\nlookup(shptable::AG.IFeatureLayer, \n\tcolumn::Union{AbstractString, Symbol}, entries::AbstractArray)\nlookup(shptable::AG.IFeatureLayer)\n\nFind row(s) in the shape table whose column record(s) equal(s) to entry  or elements of entries. When the third argument is an array, results are  output as an array of the same shape by broadcasting. \n\n\n\n\n\n","category":"function"},{"location":"manual/#Internal-functions","page":"Manual","title":"Internal functions","text":"","category":"section"},{"location":"manual/","page":"Manual","title":"Manual","text":"Mikrubi.filterext\nMikrubi.goodcolumns","category":"page"},{"location":"manual/#Mikrubi.filterext","page":"Manual","title":"Mikrubi.filterext","text":"filterext(dir::AbstractString, extset=nothing) :: Vector{String}\n\nFind all file names in dir with extensions in extset. When extset is set  to nothing (by default), all extensions are acceptable.\n\n\n\n\n\n","category":"function"},{"location":"manual/#Mikrubi.goodcolumns","page":"Manual","title":"Mikrubi.goodcolumns","text":"goodcolumns(shptable::AG.IFeatureLayer) :: Dict{String, Vector}\n\nFind all properties of features in shptable where entries are all unique and  either integers or strings (types whose isequal is well-defined).\n\n\n\n\n\n","category":"function"},{"location":"manual/#Reading-and-writing-list-file","page":"Manual","title":"Reading and writing list file","text":"","category":"section"},{"location":"manual/","page":"Manual","title":"Manual","text":"List of occupied counties can be prepared explicitly in Julia as a vector or a set. Meanwhile, it is also possible to read from or write to disk such a list, especially when the list is generated outside Julia.","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"readlist\nwritelist","category":"page"},{"location":"manual/#Mikrubi.readlist","page":"Manual","title":"Mikrubi.readlist","text":"readlist(path::AbstractString) :: Vector\n\nRead any list of vector from file at path.\n\n\n\n\n\n","category":"function"},{"location":"manual/#Mikrubi.writelist","page":"Manual","title":"Mikrubi.writelist","text":"writelist(path::AbstractString, list::AbstractVector) :: Nothing\n\nWrite any list or vector to file at path.\n\n\n\n\n\n","category":"function"},{"location":"manual/#Reading-and-writing-raster-layers","page":"Manual","title":"Reading and writing raster layers","text":"","category":"section"},{"location":"manual/","page":"Manual","title":"Manual","text":"Climatic factors are downloaded and stored as raster layers. Mikrubi reads such layers by readlayers, performs principal component analysis on them and returns the results as layers also. When the output layers need to be kept for future use, they can be written to disk using writelayers. Moreover, when the predicted distribution of species is organized in raster format, it can be saved likewise using writelayer.","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"readlayers\nwritelayer\nwritelayers","category":"page"},{"location":"manual/#Mikrubi.readlayers","page":"Manual","title":"Mikrubi.readlayers","text":"readlayers(filenames::Vector{<:AbstractString}) :: RasterStack\nreadlayers(dir::AbstractString; extset=nothing) :: RasterStack\n\nRead all raster layers from the directory dir as a RasterStack. \n\nextset describes possible extensions of raster files (e.g., Set(\".tif\"),  or [\".tiff\"]; see also readshape). By setting extset to  nothing, the extension filtering is not processed, i.e., all files are  regarded as raster files. \n\n\n\n\n\n","category":"function"},{"location":"manual/#Mikrubi.writelayer","page":"Manual","title":"Mikrubi.writelayer","text":"writelayer(path::AbstractString, layer::Raster) :: Nothing\n\nWrite layer to the disk at path. Alias for GeoArrays.write!.\n\n\n\n\n\n","category":"function"},{"location":"manual/#Mikrubi.writelayers","page":"Manual","title":"Mikrubi.writelayers","text":"writelayers(paths::AbstractVector{<:AbstractString}, \n\tlayers::RasterStack) :: Nothing\nwritelayers(pathformula::AbstractString, layers::RasterStack) :: Nothing\n\nWrite layers to paths respondingly, or a series of paths generated by the pathformula where an asterisk is used for wildcard and replaced by numbers.\n\n\n\n\n\n","category":"function"},{"location":"manual/#Internal-functions-2","page":"Manual","title":"Internal functions","text":"","category":"section"},{"location":"manual/","page":"Manual","title":"Manual","text":"It is worth mention that when reading layers from a directory, files are sorted according to their names in a manner similar to the sorting order in Windows OS. Please pay extra attention when two parallel raster stacks are fed into makefield. ","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"Mikrubi.sortfilenames!\nMikrubi.allsame","category":"page"},{"location":"manual/#Mikrubi.sortfilenames!","page":"Manual","title":"Mikrubi.sortfilenames!","text":"sortfilenames!(filenames::AbstractVector{<:AbstractString})\n\nSort filenames in place according to the order of the distinctive parts  among them. If all of the distinctive parts are decimal numerals, they are  sorted as integers.\n\nExamples\n\njulia> sortfilenames!([\"bio_9.tif\", \"bio_10.tif\", \"bio_1.tif\"])\n[ Info: 3 files \"bio_*.tif\" recognized in the directory, where * = 1, 9, 10.\n3-element Array{String,1}:\n \"bio_1.tif\"\n \"bio_9.tif\"\n \"bio_10.tif\"\n\njulia> sortfilenames!([\"bio_09.tif\", \"bio_10.tif\", \"bio_01.tif\"])\n[ Info: 3 files \"bio_*.tif\" recognized in the directory, where * = 01, 09, 10.\n3-element Array{String,1}:\n \"bio_01.tif\"\n \"bio_09.tif\"\n \"bio_10.tif\"\n\n\n\n\n\n","category":"function"},{"location":"manual/#Mikrubi.allsame","page":"Manual","title":"Mikrubi.allsame","text":"allsame(a::AbstractVector) :: Bool\n\nReturn true if all elements from a are identical, or otherwise false.  An error is thrown if the vector a is empty.\n\nExamples\n\njulia> allsame([1, 1, 2])\nfalse\n\njulia> allsame([1, 1, 1])\ntrue\n\njulia> allsame([1])\ntrue\n\njulia> allsame([])\nERROR: BoundsError: attempt to access 0-element Array{Any,1} at index [1]\nStacktrace:\n [1] getindex at .\\array.jl:787 [inlined]\n [2] allsame(::Array{Any,1}) at .\\REPL[9]:1\n [3] top-level scope at REPL[20]:1\n\n\n\n\n\n","category":"function"},{"location":"manual/#Reading-and-writing-Mikrubi-fields","page":"Manual","title":"Reading and writing Mikrubi fields","text":"","category":"section"},{"location":"manual/","page":"Manual","title":"Manual","text":"MikrubiField is a specially designed type where the environmental information of pixels and their county identifiers are nested. It may be necessary to save (by writefield) and load (by readfield) a Mikrubi field especially when it is used on multiple species.","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"readfield\nwritefield","category":"page"},{"location":"manual/#Mikrubi.readfield","page":"Manual","title":"Mikrubi.readfield","text":"readfield(path::AbstractString) :: MikrubiField\n\nRead a Mikrubi field from file at path.\n\n\n\n\n\n","category":"function"},{"location":"manual/#Mikrubi.writefield","page":"Manual","title":"Mikrubi.writefield","text":"writefield(path::AbstractString, field::MikrubiField) :: Nothing\n\nWrite a Mikrubi field to file at path.\n\n\n\n\n\n","category":"function"},{"location":"manual/#Reading-and-writing-Mikrubi-models","page":"Manual","title":"Reading and writing Mikrubi models","text":"","category":"section"},{"location":"manual/","page":"Manual","title":"Manual","text":"MikrubiModel is a struct containing transformation parameters. It can be read from and written to disk using respectively readmodel and writemodel. ","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"readmodel\nwritemodel","category":"page"},{"location":"manual/#Mikrubi.readmodel","page":"Manual","title":"Mikrubi.readmodel","text":"readmodel(path::AbstractString) :: MikrubiModel\n\nRead a Mikrubi model from file at path.\n\n\n\n\n\n","category":"function"},{"location":"manual/#Mikrubi.writemodel","page":"Manual","title":"Mikrubi.writemodel","text":"writemodel(path::AbstractString, model::MikrubiModel) :: Nothing\n\nWrite a Mikrubi model to file at path.\n\n\n\n\n\n","category":"function"},{"location":"manual/#Rasterizing-a-shapefile","page":"Manual","title":"Rasterizing a shapefile","text":"","category":"section"},{"location":"manual/","page":"Manual","title":"Manual","text":"Since v1.3.0, Mikrubi no longer provides its own rasterization routine; the implementation from Rasters is applied instead. The function rasterize in Mikrubi integrates the rasterization of multiple geometries. The returned value is of an internal type Mikrubi.CtPixels.","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"rasterize\nMikrubi.CtPixels","category":"page"},{"location":"manual/#Mikrubi.rasterize","page":"Manual","title":"Mikrubi.rasterize","text":"rasterize(geoms, layer::Raster) :: CtPixels\nrasterize(shptable::AG.IFeatureLayer, layer::Raster) :: CtPixels\n\nFor a collection of (multi)polygons, rasterize each of them and write the  results in a CtPixels.\n\n\n\n\n\n","category":"function"},{"location":"manual/#Mikrubi.CtPixels","page":"Manual","title":"Mikrubi.CtPixels","text":"CtPixels\n\nCtPixels(indices::Raster{Int})\n\nCollector for county-specific rasterization results, whose list contains  county-pixel tuples. Can only be instantiated from an index raster  (see indicate).\n\n\n\n\n\n","category":"type"},{"location":"manual/#Internal-functions-3","page":"Manual","title":"Internal functions","text":"","category":"section"},{"location":"manual/","page":"Manual","title":"Manual","text":"Mikrubi.getpixels\nMikrubi.getcounties\nMikrubi.getpixel\nMikrubi.getcounty\nMikrubi.indicate\nMikrubi.register!\nMikrubi.ispoly","category":"page"},{"location":"manual/#Mikrubi.getpixels","page":"Manual","title":"Mikrubi.getpixels","text":"getpixels(ctpixels::CtPixels) :: Vector{Int}\n\nGet pixel indices from ctpixels.\n\n\n\n\n\n","category":"function"},{"location":"manual/#Mikrubi.getcounties","page":"Manual","title":"Mikrubi.getcounties","text":"getcounties(ctpixels::CtPixels) :: Vector{Int}\n\nGet county indices from ctpixels.\n\n\n\n\n\n","category":"function"},{"location":"manual/#Mikrubi.getpixel","page":"Manual","title":"Mikrubi.getpixel","text":"getpixel(ctpixels::CtPixels, i::Int) :: Int\n\nGet the pixel index of the i-th county-pixel tuple in ctpixels.\n\n\n\n\n\n","category":"function"},{"location":"manual/#Mikrubi.getcounty","page":"Manual","title":"Mikrubi.getcounty","text":"getcounty(ctpixels::CtPixels, i::Int) :: Int\n\nGet the county index of the i-th county-pixel tuple in ctpixels.\n\n\n\n\n\n","category":"function"},{"location":"manual/#Mikrubi.indicate","page":"Manual","title":"Mikrubi.indicate","text":"indicate(layer::Raster) :: Raster{Int}\n\nBuild an index raster indices from layer. The value of an array element in  indices is either (1) 0 for missing, if the corresponding element in  layer is missing; or (2) the integer index of the array element, otherwise. \n\n\n\n\n\n","category":"function"},{"location":"manual/#Mikrubi.register!","page":"Manual","title":"Mikrubi.register!","text":"register!(ctpixels::CtPixels, ct::Int, pixel::Int) :: Int\n\nPush a county-pixel tuple into ctpixels, if pixel is not zero. For  convenience, the value of pixel is returned. \n\n\n\n\n\nregister!(ctpixels::CtPixels, ct::Int) :: Function\n\nCreate a function that accepts a pixel, pushes the county-pixel tuple into  ctpixels, and finally returns the value of pixel.\n\n\n\n\n\n","category":"function"},{"location":"manual/#Mikrubi.ispoly","page":"Manual","title":"Mikrubi.ispoly","text":"ispoly(geom) :: Bool\n\nCheck if geom is a polygon or a multipolygon.\n\n\n\n\n\n","category":"function"},{"location":"manual/#makefield","page":"Manual","title":"Processing the raster layers","text":"","category":"section"},{"location":"manual/","page":"Manual","title":"Manual","text":"In Mikrubi, climatic factors after being read in typically undergo some processing steps together with shapefile inside the function makefield, which returns a Mikrubi field and a stack of extracted components in raster layers. The two outputs can be used for training and prediction.","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"Sometimes it is also required to apply a model to another circumstance (different time or different space), in which case another series of parallel climatic factor layers need to be processed in exactly the same way as those used to generate the Mikrubi field (so that their climatic meanings are the same). Such layers need to be put in the third place in the input argument list for makefield, and those parallelly extracted components are returned in the third place in output as well.","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"makefield","category":"page"},{"location":"manual/#Mikrubi.makefield","page":"Manual","title":"Mikrubi.makefield","text":"makefield(layers::RasterStack, ctpixels::CtPixels; \n\trabsthres=0.8, nprincomp=3) :: Tuple{MikrubiField, RasterStack}\nmakefield(layers::RasterStack, ctpixels::CtPixels, \n\tplayers::RasterStack; rabsthres=0.8, nprincomp=3)\n\t\t:: Tuple{MikrubiField, RasterStack, RasterStack}\nmakefield(layers::RasterStack, shptable; rabsthres=0.8, nprincomp=3)\n\t:: Tuple{MikrubiField, RasterStack}\nmakefield(layers::RasterStack, shptable, players::RasterStack; \n\trabsthres=0.8, nprincomp=3)\n\t\t:: Tuple{MikrubiField, RasterStack, RasterStack}\n\nCreate a MikrubiField as well as processed variable layers from layers   and shptable or ctpixels, by \n\n(rasterizing the shptable to ctpixels using rasterize,) \nmasking the layers with ctpixels (using Mikrubi.masklayers!), \nextracting non-missing pixels from layers (using Mikrubi.extractlayers),\nselecting less correlated variables (using Mikrubi.selectvars), and \ndoing the principal component analysis (using Mikrubi.princompvars).\n\nOptional keyword arguments\n\nrabsthres: threshold of collinearity.\n\nAbsolute value of Pearson correlation efficient greater than this threshold  is identified as collinearity and the two variables are thus incompatible. \n\nnprincomp: expected number of principal components of the variables.\n\nNotes about players\n\nWhen players is present in the argument list, raster layers it contains  experience the same process including subsetting, selecting, and taking  principal components, and results are packed and returned in the third place.  User must assure that players has the same length as layers, and  their elements are corresponding in order. This would be useful when the  prediction is in another geographic range or at another time.\n\n\n\n\n\n","category":"function"},{"location":"manual/#Internal-functions-4","page":"Manual","title":"Internal functions","text":"","category":"section"},{"location":"manual/","page":"Manual","title":"Manual","text":"Mikrubi.colmatrix\nMikrubi.masklayers!\nMikrubi.extractlayers\nMikrubi.emptylayer!\nMikrubi.emptylayer\nMikrubi.emptylayers\nMikrubi.makelayer\nMikrubi.makelayers\nMikrubi.dftraverse!\nMikrubi.selectvars\nMikrubi.princompvars\nMikrubi.DimLower\nMikrubi.dimpoints\nMikrubi.centercoords\nMikrubi.buildfield","category":"page"},{"location":"manual/#Mikrubi.colmatrix","page":"Manual","title":"Mikrubi.colmatrix","text":"colmatrix(vector::AbstractVector) :: AbstractMatrix\ncolmatrix(matrix::AbstractMatrix) :: AbstractMatrix\n\nReturn a one-column matrix if the argument is a vector, or the matrix itself  if the argument is already a matrix.\n\n\n\n\n\n","category":"function"},{"location":"manual/#Mikrubi.masklayers!","page":"Manual","title":"Mikrubi.masklayers!","text":"masklayers!(layers::RasterStack, ctpixels::CtPixels) :: RasterStack\n\nMask the layers in a way that only pixels present in ctpixels are kept,  while all other uncovered pixels are set to a missing value.\n\n\n\n\n\n","category":"function"},{"location":"manual/#Mikrubi.extractlayers","page":"Manual","title":"Mikrubi.extractlayers","text":"extractlayers(layers::RasterStack) :: Tuple{Matrix, Vector{Int}}\n\nExtract the non-missing pixels from layers, and combine them into a matrix,  whose rows representing pixels and columns representing variables.\n\nextractlayers is the inverse function of makelayers.\n\n\n\n\n\n","category":"function"},{"location":"manual/#Mikrubi.emptylayer!","page":"Manual","title":"Mikrubi.emptylayer!","text":"emptylayer!(grid::Raster) :: Raster\n\nFill the grid with missing values in place.\n\n\n\n\n\n","category":"function"},{"location":"manual/#Mikrubi.emptylayer","page":"Manual","title":"Mikrubi.emptylayer","text":"emptylayer(grid::Raster) :: Raster\n\nCreate a new Raster full of missing values from the shape of grid.\n\n\n\n\n\n","category":"function"},{"location":"manual/#Mikrubi.emptylayers","page":"Manual","title":"Mikrubi.emptylayers","text":"emptylayers(grid::Raster, m::Int) :: RasterStack\n\nCreate a RasterStack with m empty Rasters (full of missing values) from  the shape of grid.\n\n\n\n\n\n","category":"function"},{"location":"manual/#Mikrubi.makelayer","page":"Manual","title":"Mikrubi.makelayer","text":"makelayer(vector::AbstractVector, idx::AbstractVector, grid::Raster)\n\nMake a Raster from the grid and values in vector. \n\nFor making a RasterStack from a matrix, see makelayers.\n\n\n\n\n\n","category":"function"},{"location":"manual/#Mikrubi.makelayers","page":"Manual","title":"Mikrubi.makelayers","text":"makelayers(matrix::AbstractMatrix, idx::AbstractVector, grid::Raster) \n\t:: RasterStack\n\nMake a RasterStack from the grid and values in columns of matrix.\n\nFor making a Raster from a column vector, see makelayer.\n\nmakelayers is the inverse function of extractlayers.\n\n\n\n\n\n","category":"function"},{"location":"manual/#Mikrubi.dftraverse!","page":"Manual","title":"Mikrubi.dftraverse!","text":"dftraverse!(beststate, bestscore, state, score, depth, maxdepth, \n\tincompat, scoremat) :: Nothing\n\nFind the index combination that\n\nfirstly containing as many indices as possible, and\nsecondly with the lowest pairwise sum from submatrix of scoremat,\n\nsuch that no indices i and j coexist as long as incompat[i][j] == true.\n\nThe result is stored as the only element of beststate, with its score decided by the two criteria above stored as the only element of bestscore.\n\nExample\n\njulia> beststate = Vector(undef, 1);\n\njulia> bestscore = [(0, 0.0)];\n\njulia> dftraverse!(beststate, bestscore, Int[], (0, 0.0), 1, 3,\n           Bool[0 0 1; 0 0 0; 1 0 0],\n           [0.0 0.6 0.3; 0.6 0.0 0.9; 0.3 0.9 0.0]);\n\njulia> beststate\n1-element Array{Any,1}:\n [1, 2]\n\njulia> bestscore\n1-element Array{Tuple{Int64,Float64},1}:\n (2, -0.6)\n\n\n\n\n\n","category":"function"},{"location":"manual/#Mikrubi.selectvars","page":"Manual","title":"Mikrubi.selectvars","text":"selectvars(matrix::Matrix, rabsthres=0.8) :: Vector{Int}\n\nSelect as many variables as possible from matrix such that no pairwise Pearson coefficient among them exceeds rabsthres and their sum is minimal.\n\nExample\n\njulia> selectvars([1. 4. 7.; 2. 5. 8.; 3. 9. 27.], rabsthres=0.9)\n2-element Array{Int64,1}:\n 1\n 3\n\n\n\n\n\n","category":"function"},{"location":"manual/#Mikrubi.princompvars","page":"Manual","title":"Mikrubi.princompvars","text":"princompvars(smatrix::Matrix; nprincomp=3) :: Tuple{Vector, Matrix}\n\nPerform principal component analysis on smatrix whose columns represents variables, and combines the nprincomp principal components into a matrix, and returns the result matrix as well as the affine transformation (colmean, projwstd), such that the result matrix == (smatrix .- colmean) * projwstd.\n\n\n\n\n\n","category":"function"},{"location":"manual/#Mikrubi.DimLower","page":"Manual","title":"Mikrubi.DimLower","text":"DimLower\n\nDimLower()\n\nA container for transformation used in makefield, working as a function. If  it is new (new=true), the parameters (colid, colmean, and projwstd)  are computed when it is applied on a RasterStack. \n\n\n\n\n\n","category":"type"},{"location":"manual/#Mikrubi.dimpoints","page":"Manual","title":"Mikrubi.dimpoints","text":"dimpoints(grid::Raster) :: DimPoints\n\nCreate a DimensionalData.DimPoints from grid after shifting all its  dimension loci to Center(). Similar to GeoArrays.coords.\n\n\n\n\n\n","category":"function"},{"location":"manual/#Mikrubi.centercoords","page":"Manual","title":"Mikrubi.centercoords","text":"centercoords(dp::DimPoints, ci::CartesianIndices, idx::Int) \n\t:: Tuple{AbstractFloat, AbstractFloat}\n\nGet center coordinates of a grid cell indexed by idx in a Raster.\n\n\n\n\n\n","category":"function"},{"location":"manual/#Mikrubi.buildfield","page":"Manual","title":"Mikrubi.buildfield","text":"buildfield(ctpixels::CtPixels, idx::Vector, \n\tprojmat::Matrix, grid::Raster) :: MikrubiField\n\nConstruct a MikrubiField from ctpixels, idx, projmat, and grid. Used in  makefield.\n\n\n\n\n\n","category":"function"},{"location":"manual/#The-Mikrubi-core","page":"Manual","title":"The Mikrubi core","text":"","category":"section"},{"location":"manual/","page":"Manual","title":"Manual","text":"Two specially designed structs are involved in the core of Mikrubi.","category":"page"},{"location":"manual/#Mikrubi-field","page":"Manual","title":"Mikrubi field","text":"","category":"section"},{"location":"manual/","page":"Manual","title":"Manual","text":"MikrubiField is a struct containing mainly three types of information of pixels/points, that is, which counties they belong to (ctids), their geographic coordinates (locs), and their environmental coordinates (vars), with also some derived assistant attributes, such as geographic dimensionality (usually 2) and environmental dimensionality (for example, 3).","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"MikrubiField can be obtained in three ways: as first output argument of makefield, read from disk, or constructed directly from the three required attributes (this may be useful for simulation analysis). ","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"MikrubiField","category":"page"},{"location":"manual/#Mikrubi.MikrubiField","page":"Manual","title":"Mikrubi.MikrubiField","text":"MikrubiField{T, U <: Real, V <: AbstractFloat}\n\nMikrubiField(ctids, locs, vars)\n\nConstruct a Mikrubi field containing a number of pixels or points, using the arguments which should always have the same number of rows\n\nctids::Vector: a vector containing the county identifiers\nlocs::Array{<:Real}: an array of geographic coordinates\nvars::Matrix{<:AbstractFloat}: an array of environmental coordinates\n\n\n\n\n\n","category":"type"},{"location":"manual/#Mikrubi-model","page":"Manual","title":"Mikrubi model","text":"","category":"section"},{"location":"manual/","page":"Manual","title":"Manual","text":"MikrubiModel contains the environmental dimensionality and the model parameters to define a positive-definite quadratic mapping from environmental space to a real number axis. ","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"Like MikrubiField, MikrubiField can be obtained in three ways: as output argument of fit, read from disk, or constructed directly from attributes. An example of obtaining Mikrubi field and Mikrubi model from constructors are available in examples/onedimsim/sim.jl.","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"MikrubiModel","category":"page"},{"location":"manual/#Mikrubi.MikrubiModel","page":"Manual","title":"Mikrubi.MikrubiModel","text":"MikrubiModel{V <: AbstractFloat}\n\nMikrubiModel(dvar::Int, params::Vector{<:AbstractFloat})\n\nConstruct a Mikrubi Model from a dimensionality dvar and a parameter vector params. The equation must hold for dvar2dparam(dvar) == length(params).\n\nMikrubi Models can be obtained from the function fit, and can be used in the function predict.\n\n\n\n\n\n","category":"type"},{"location":"manual/#fitfuncm","page":"Manual","title":"Fitting a Mikrubi model","text":"","category":"section"},{"location":"manual/","page":"Manual","title":"Manual","text":"When a Mikrubi field as well as occurrence data in county and/or in coordinates are ready, they can be used to train a Mikrubi model by function fit (county data at counties, required; coordinates at coords, optional). Result is output as a MikrubiModel.","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"fit(field::MikrubiField, counties, coords=zeros(0, 0))","category":"page"},{"location":"manual/#Mikrubi.fit","page":"Manual","title":"Mikrubi.fit","text":"fit(field::MikrubiField, counties, coords=zeros(0, 0); \n\toptresult=[], iterations=3_000_000, kwargs...) :: MikrubiModel\n\nNumerically find the Mikrubi model maximizing the likelihood that the occupied  counties as well as the occupied coordinates are sampled in the given Mikrubi  field. The optimization result is stored in the container optresult for  debugging.\n\n\n\n\n\n","category":"function"},{"location":"manual/#Predicting-from-a-Mikrubi-model","page":"Manual","title":"Predicting from a Mikrubi model","text":"","category":"section"},{"location":"manual/","page":"Manual","title":"Manual","text":"A Mikrubi model can be applied by function predict to a matrix with its columns corresponding to extracted variables, a stack of extracted layers, or a Mikrubi field. ","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"When input argument is a matrix, output argument is a column vector denoting the probability of presence in pixels/points related to rows in the matrix.\nWhen input argument is a stack of layers, output argument is a single layer denoting the probability of presence.\nWhen input argument is a Mikrubi field, output argument is a Dict which maps every county identifier to probability of presence at pixels inside the county, see also predictcounty.","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"predict","category":"page"},{"location":"manual/#Mikrubi.predict","page":"Manual","title":"Mikrubi.predict","text":"predict(matrix::AbstractMatrix, model::MikrubiModel) :: Vector\npredict(layers::RasterStack, model::MikrubiModel) :: Raster\npredict(field::MikrubiField, model::MikrubiModel) \n\t:: Dict{<:Any, <:Vector{<:Tuple{Vector{<:Real}, AbstractFloat}}}\n\nPredict the probability of presence according to processed climatic factors  (matrix / layers) or on the Mikrubi field.\n\n\n\n\n\n","category":"function"},{"location":"manual/","page":"Manual","title":"Manual","text":"When distribution probability within only one county is concerned, predictcounty returns probability of presence at all pixels that constitute the county in descending order. Therefore, the first element represents the most likely occupied pixel of a county.","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"predictcounty","category":"page"},{"location":"manual/#Mikrubi.predictcounty","page":"Manual","title":"Mikrubi.predictcounty","text":"predictcounty(field::MikrubiField, model::MikrubiModel, county) \n\t:: Vector{<:Tuple{Vector{<:Real}, AbstractFloat}}\n\nReturn the geographic coordinates of pixels in the county sorted by the likeliness of being occupied.\n\n\n\n\n\n","category":"function"},{"location":"manual/","page":"Manual","title":"Manual","text":"It is also possible to obtain the overall probability that every county is occupied by the function probcounties.","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"probcounties","category":"page"},{"location":"manual/#Mikrubi.probcounties","page":"Manual","title":"Mikrubi.probcounties","text":"probcounties(field::MikrubiField, model::MikrubiModel) \n\t:: Dict{<:Any, <:AbstractFloat}\nprobcounties(::Type{<:Logistic}, field::MikrubiField, model::MikrubiModel) \n\t:: Dict{<:Any, <:Logistic}\n\nCompute the probability for every county to be occupied in the field. \n\n\n\n\n\n","category":"function"},{"location":"manual/#Sampling-counties-in-a-Mikrubi-field","page":"Manual","title":"Sampling counties in a Mikrubi field","text":"","category":"section"},{"location":"manual/","page":"Manual","title":"Manual","text":"For simulation analysis, sometimes it is required to sample a set of counties from a Mikrubi field and a Mikrubi model. samplecounties does the trick.","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"samplecounties","category":"page"},{"location":"manual/#Mikrubi.samplecounties","page":"Manual","title":"Mikrubi.samplecounties","text":"samplecounties(field::MikrubiField, model::MikrubiModel) :: Vector\n\nSample counties according to their probability of being occupied.\n\n\n\n\n\n","category":"function"},{"location":"manual/#Detecting-overfitting","page":"Manual","title":"Detecting overfitting","text":"","category":"section"},{"location":"manual/","page":"Manual","title":"Manual","text":"Overfitting can be detected with the Lipschitz constant, the (logarithmic) maximum gradient (in norm) of the probability of presence in environmental space.","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"lipschitz","category":"page"},{"location":"manual/#Mikrubi.lipschitz","page":"Manual","title":"Mikrubi.lipschitz","text":"lipschitz(model::MikrubiModel, field::MikrubiField; wholespace=false) \n\t:: AbstractFloat\n\nCalculate the maximum gradient (in norm) of the probability of presence over  the field. When wholespace=false (default), the maximum is taken among the  points contained in field; otherwise it is taken around the whole space.\n\n\n\n\n\n","category":"function"},{"location":"manual/#Internal-functions-5","page":"Manual","title":"Internal functions","text":"","category":"section"},{"location":"manual/","page":"Manual","title":"Manual","text":"Mikrubi.dvar2dparam\nMikrubi.decomparams\nMikrubi.pabsence\nMikrubi.ppresence\nMikrubi.mlogL\nMikrubi.probpixels\nMikrubi.findnearest\nMikrubi.findnearests\nMikrubi.loglipschitz\nMikrubi.textwrap\nMikrubi.@tw_str","category":"page"},{"location":"manual/#Mikrubi.dvar2dparam","page":"Manual","title":"Mikrubi.dvar2dparam","text":"dvar2dparam(dvar::Int) :: Int\n\nConvert dimensionality of an environmental space to the dimensionality of the induced parameter space, i.e., compute the degrees of freedom for  positive-definite quadratic functions mapping a dvar-dimensional linear space into real numbers.\n\nExamples\n\njulia> dvar2dparam(1)\n3\n\njulia> dvar2dparam(3)\n10\n\n\n\n\n\n","category":"function"},{"location":"manual/#Mikrubi.decomparams","page":"Manual","title":"Mikrubi.decomparams","text":"decomparams(p::AbstractVector, d::Int) :: Tuple{Matrix, Vector, Any}\ndecomparams(model::MikrubiModel) :: Tuple{Matrix, Vector, Any}\n\nReturn parameter decomposition At, b, c, where \n\nAt is a lower triangular matrix of size (d, d),\nb is a column vector of size d, and\nc is a scalar.\n\nWARNING: The vector p must have length dvar2dparam(d).\n\nExample\n\njulia> decomparams(collect(1:10), 3)\n([1 0 0; 2 3 0; 4 5 6], [7, 8, 9], 10)\n\n\n\n\n\n","category":"function"},{"location":"manual/#Mikrubi.pabsence","page":"Manual","title":"Mikrubi.pabsence","text":"pabsence(vars::AbstractMatrix, params::AbstractVector) :: Logistic\npabsence(field::MikrubiField, params::AbstractVector) :: Logistic\n\nCompute the probability of absence at pixels given vars/field and params.\t\n\n\n\n\n\n","category":"function"},{"location":"manual/#Mikrubi.ppresence","page":"Manual","title":"Mikrubi.ppresence","text":"ppresence(vars::AbstractMatrix, params::AbstractVector) :: Logistic\nppresence(field::MikrubiField, params::AbstractVector) :: Logistic\n\nCompute the probability of presence at pixels given vars/field and params.\t\n\n\n\n\n\n","category":"function"},{"location":"manual/#Mikrubi.mlogL","page":"Manual","title":"Mikrubi.mlogL","text":"mlogL(field::MikrubiField, counties, params::AbstractVector)\n\t:: AbstractFloat\nmlogL(vars::AbstractMatrix, params::AbstractVector) :: AbstractFloat\n\nCompute the opposite log-likelihood that the occupied counties or occupied  coordinates are sampled. The opposite is taken for optimization.\n\n\n\n\n\n","category":"function"},{"location":"manual/#Mikrubi.probpixels","page":"Manual","title":"Mikrubi.probpixels","text":"probpixels(field::MikrubiField, model::MikrubiModel) \n\t:: Vector{<:AbstractFloat}\n\nCompute the probability for every pixel to be occupied in the field. \n\n\n\n\n\n","category":"function"},{"location":"manual/#Mikrubi.findnearest","page":"Manual","title":"Mikrubi.findnearest","text":"findnearest(loc::AbstractVecOrMat{<:Real}, field::MikrubiField) :: Int\n\nReturn the row index in field.locs which is the nearest to the given  coordinates.\n\n\n\n\n\n","category":"function"},{"location":"manual/#Mikrubi.findnearests","page":"Manual","title":"Mikrubi.findnearests","text":"findnearests(loc::AbstractVector{<:AbstractVecOrMat}, field::MikrubiField) \n\t:: Vector{Int}\nfindnearests(loc::AbstractMatrix{<:Real}, field::MikrubiField) \n\t:: Vector{Int}\n\nReturn the row indices in field.locs which are the nearest to each of the  given coordinates. Duplicate results are reduced to one.\n\n\n\n\n\n","category":"function"},{"location":"manual/#Mikrubi.loglipschitz","page":"Manual","title":"Mikrubi.loglipschitz","text":"loglipschitz(model::MikrubiModel, field::MikrubiField; wholespace=false) \n\t:: AbstractFloat\n\nCalculate the (logarithmic) maximum gradient (in norm) of the probability of  presence over the field. When wholespace=false (default), the maximum is  taken among the points contained in field; otherwise it is taken around the  whole space.\n\n\n\n\n\n","category":"function"},{"location":"manual/#Mikrubi.textwrap","page":"Manual","title":"Mikrubi.textwrap","text":"textwrap(str::AbstractString) :: String\n\nGobble all linefeeds (\"\\n\") inside str and replaces them with spaces (\"\"), so long strings can be wrapped to multiple lines in the codes, like  the Python package \"textwrap\". See also tw.\n\n\n\n\n\n","category":"function"},{"location":"manual/#Mikrubi.@tw_str","page":"Manual","title":"Mikrubi.@tw_str","text":"@tw_str :: String\n\nMacro version of textwrap, without interpolation and unescaping.\n\n\n\n\n\n","category":"macro"},{"location":"graphics/#Graphics","page":"Graphics","title":"Graphics","text":"","category":"section"},{"location":"graphics/","page":"Graphics","title":"Graphics","text":"Pages = [\"graphics.md\"]\nDepth = 4","category":"page"},{"location":"graphics/","page":"Graphics","title":"Graphics","text":"Module = Mikrubi","category":"page"},{"location":"graphics/","page":"Graphics","title":"Graphics","text":"Objects in Mikrubi of various types (shape files, rasters, raster stacks, Mikrubi.CtPixels instances, Mikrubi fields) can be plotted by Plots or by PyPlot. ","category":"page"},{"location":"graphics/#Plotting-with-Plots","page":"Graphics","title":"Plotting with Plots","text":"","category":"section"},{"location":"graphics/","page":"Graphics","title":"Graphics","text":"After loading the Plots package, the objects can be plotted by plot or plot!. ","category":"page"},{"location":"graphics/#Example-of-*Prinsepia-utilis*","page":"Graphics","title":"Example of Prinsepia utilis","text":"","category":"section"},{"location":"graphics/","page":"Graphics","title":"Graphics","text":"Here we use the distribution of Prinsepia utilis (Rosaceae) in Nepal as an example. First we get all the objects prepared.","category":"page"},{"location":"graphics/","page":"Graphics","title":"Graphics","text":"using Mikrubi\nusing Plots\nimport GADM\nimport RasterDataSources; const RDS = RasterDataSources\n\nshppath = GADM.download(\"NPL\")\n\nget!(ENV, \"RASTERDATASOURCES_PATH\", tempdir())\nRDS.getraster(RDS.WorldClim{RDS.BioClim}, res=\"10m\")\nclimpath = RDS.rasterpath(RDS.WorldClim{RDS.BioClim})","category":"page"},{"location":"graphics/#Illustrating-the-shape-file","page":"Graphics","title":"Illustrating the shape file","text":"","category":"section"},{"location":"graphics/","page":"Graphics","title":"Graphics","text":"The variable shptable, what is read through readshape, called a shape file here, can be plotted.","category":"page"},{"location":"graphics/","page":"Graphics","title":"Graphics","text":"shptable = readshape(shppath, 3);\n\nplot(shptable)\nsavefig(\"plots_shptable.png\")","category":"page"},{"location":"graphics/","page":"Graphics","title":"Graphics","text":"(Image: plots_shptable.png)","category":"page"},{"location":"graphics/#Illustrating-the-raster-layers","page":"Graphics","title":"Illustrating the raster layers","text":"","category":"section"},{"location":"graphics/","page":"Graphics","title":"Graphics","text":"We read the WorldClim raster layers, and extract the first raster layer from the stack, and then plot it.","category":"page"},{"location":"graphics/","page":"Graphics","title":"Graphics","text":"layers = readlayers(climpath)\nlayer = first(layers)\n\nplot(layer)\nsavefig(\"plots_layer.png\")","category":"page"},{"location":"graphics/","page":"Graphics","title":"Graphics","text":"(Image: plots_layer.png)","category":"page"},{"location":"graphics/#Illustrating-the-rasterization-result","page":"Graphics","title":"Illustrating the rasterization result","text":"","category":"section"},{"location":"graphics/","page":"Graphics","title":"Graphics","text":"Here ctpixels is the object storing the rasterization result, although in many cases the result is hidden in makefield. ","category":"page"},{"location":"graphics/","page":"Graphics","title":"Graphics","text":"ctpixels = rasterize(shptable, layer);\n\nplot(ctpixels)\nsavefig(\"plots_ctpixels.png\")","category":"page"},{"location":"graphics/","page":"Graphics","title":"Graphics","text":"(Image: plots_ctpixels.png)","category":"page"},{"location":"graphics/#Illustrating-the-Mikrubi-field","page":"Graphics","title":"Illustrating the Mikrubi field","text":"","category":"section"},{"location":"graphics/","page":"Graphics","title":"Graphics","text":"A Mikrubi field cannot be plotted solely, because it does not contain enough information for illustrating. It must follow the corresponding raster grid in the argument list.","category":"page"},{"location":"graphics/","page":"Graphics","title":"Graphics","text":"field, ylayers = makefield(layers, shptable);\n\nplot(layer, field)\nsavefig(\"plots_field.png\")","category":"page"},{"location":"graphics/","page":"Graphics","title":"Graphics","text":"(Image: plots_field.png)","category":"page"},{"location":"graphics/#Plotting-with-PyPlot","page":"Graphics","title":"Plotting with PyPlot","text":"","category":"section"},{"location":"graphics/","page":"Graphics","title":"Graphics","text":"Since the PyPlot plotting engine is substantially the wrapped Python package matplotlib, users who wish to use PyPlot should manually install the package (e.g. pip install matplotlib in terminal). Mikrubi can use PyPlot after it is loaded in the current session by:","category":"page"},{"location":"graphics/","page":"Graphics","title":"Graphics","text":"using PyPlot","category":"page"},{"location":"graphics/","page":"Graphics","title":"Graphics","text":"Four functions are provided to illustrate the objects of different types.","category":"page"},{"location":"graphics/","page":"Graphics","title":"Graphics","text":"showshptable\nshowlayer\nshowfield\nshowctpixels","category":"page"},{"location":"graphics/#Mikrubi.showshptable","page":"Graphics","title":"Mikrubi.showshptable","text":"showshptable(shptable; ax=PyPlot.gca(), kwargs...)\n\nShow lines from polygons in shptable. Identical segments are reduced as one.\n\n\n\n\n\n","category":"function"},{"location":"graphics/#Mikrubi.showlayer","page":"Graphics","title":"Mikrubi.showlayer","text":"showlayer(layer; ax=PyPlot.gca(), f=identity, kwargs...)\n\nShow a layer. Keyword argument f = identity is a function acted separately on every element. A possible alternative is f = x -> x ^ 0.4. \n\n\n\n\n\n","category":"function"},{"location":"graphics/#Mikrubi.showfield","page":"Graphics","title":"Mikrubi.showfield","text":"showfield(layer; ax=PyPlot.gca(), f=identity, kwargs...)\nshowfield(field, layer; ax=PyPlot.gca(), f=tiedrank, kwargs...)\n\nShow geographic information and environmental information of a Mikrubi model. The three principal components are reflexed in red, green, and blue. Keyword argument f = tiedrank is a function acted on columns of field.vars as a  whole. A possible alternative is f = identity.\n\n\n\n\n\n","category":"function"},{"location":"graphics/#Mikrubi.showctpixels","page":"Graphics","title":"Mikrubi.showctpixels","text":"showctpixels(ctpixels; ax=PyPlot.gca(), salt=20, kwargs...)\nshowctpixels(ctpixels, layer; ax=PyPlot.gca(), salt=20, kwargs...)\n\nShow a Mikrubi.CtPixels. Every county is assigned a hash color (influenced by a fixed salt value also), and every pixel has the composite color from all counties assigned to it. Empty cells are depicted white.\n\n\n\n\n\n","category":"function"},{"location":"graphics/#Example-of-*Allium-wallichii*","page":"Graphics","title":"Example of Allium wallichii","text":"","category":"section"},{"location":"graphics/","page":"Graphics","title":"Graphics","text":"In the beginning, here we get the packages, path strings, and decoration functions ready:","category":"page"},{"location":"graphics/","page":"Graphics","title":"Graphics","text":"using Mikrubi\nusing PyPlot\n\nshppath = \"path/to/china/counties.shp\";\nclimpath = \"path/to/worldclim/layers\";\nctlistpath = \"path/to/occupied/county/list.txt\";\n\nlargeaxis() = gca().set_position([0.06, 0.07, 0.9, 0.9])\nworldwide() = (xlim(-180, 180); ylim(-90, 90))","category":"page"},{"location":"graphics/#Illustrating-the-shape-file-and-the-raw-layers","page":"Graphics","title":"Illustrating the shape file and the raw layers","text":"","category":"section"},{"location":"graphics/","page":"Graphics","title":"Graphics","text":"Now the workflow is disassembled into steps, and we check the outputs by illustrating them.","category":"page"},{"location":"graphics/","page":"Graphics","title":"Graphics","text":"First of all, a shape file is read into Julia. We can see clearly that the boundaries of counties of China plotted in black line.","category":"page"},{"location":"graphics/","page":"Graphics","title":"Graphics","text":"shptable = readshape(shppath)\n\nfigure(figsize=(6.4, 6.4))\nshowshptable(shptable)\nlargeaxis()\nsavefig(\"pyplot_shptable.png\")\nclose()","category":"page"},{"location":"graphics/","page":"Graphics","title":"Graphics","text":"(Image: pyplot_shptable.png)","category":"page"},{"location":"graphics/","page":"Graphics","title":"Graphics","text":"Then, a series of WorldClim climatic factor layers are read in, and the first layer among them is illustrated.","category":"page"},{"location":"graphics/","page":"Graphics","title":"Graphics","text":"layers = readlayers(climpath)\n\nfigure(figsize=(6.4, 3.2))\nset_cmap(\"viridis\")\nshowlayer(first(layers))\nlargeaxis()\nworldwide()\nsavefig(\"pyplot_rawlayer1.png\")\nclose()","category":"page"},{"location":"graphics/","page":"Graphics","title":"Graphics","text":"(Image: pyplot_rawlayer1.png)","category":"page"},{"location":"graphics/#Illustrating-the-rasterization-result-2","page":"Graphics","title":"Illustrating the rasterization result","text":"","category":"section"},{"location":"graphics/","page":"Graphics","title":"Graphics","text":"Later, counties are rasterized using the grid defined by the layers. Every exclusive pixel is assigned the characteristic color of the county it belongs to, while pixels shared by multiple counties are dyed composite (thus always darker) colors.","category":"page"},{"location":"graphics/","page":"Graphics","title":"Graphics","text":"ctpixels = rasterize(shptable, first(layers))\n\nfigure(figsize=(6.4, 6.4))\nshowctpixels(ctpixels, first(layers))\nshowshptable(shptable, lw=0.5)\ngca().set_aspect(\"auto\")\nlargeaxis()\nsavefig(\"pyplot_ctpixels.png\")","category":"page"},{"location":"graphics/","page":"Graphics","title":"Graphics","text":"(Image: pyplot_ctpixels.png)","category":"page"},{"location":"graphics/","page":"Graphics","title":"Graphics","text":"Zoom in, and details of the rasterization result are clearer.","category":"page"},{"location":"graphics/","page":"Graphics","title":"Graphics","text":"xlim(88, 98)\nylim(30, 40)\nsavefig(\"pyplot_ctpixels2.png\")\nclose()","category":"page"},{"location":"graphics/","page":"Graphics","title":"Graphics","text":"(Image: pyplot_ctpixels2.png)","category":"page"},{"location":"graphics/#Illustrating-the-extracted-layers-and-the-Mikrubi-field","page":"Graphics","title":"Illustrating the extracted layers and the Mikrubi field","text":"","category":"section"},{"location":"graphics/","page":"Graphics","title":"Graphics","text":"Then, a Mikrubi field is constructed from the results above. Notable, layers lie in the input argument list at both the first and the third places. Layers at the first place are masked by the rasterization result and transformed into fewer (by default, three) layers by principal component analysis, and the results are finally assigned to elayers here. Meanwhile, layers at the third place undergo the same processes but no masking is applied, whose results are assigned to eplayers. ","category":"page"},{"location":"graphics/","page":"Graphics","title":"Graphics","text":"Now check the images of first(elayers) and first(eplayers) under the same clim, and we can see that they are actually identical on their overlapping part â€” because they are derived from the same input layers and have experienced the same operations.","category":"page"},{"location":"graphics/","page":"Graphics","title":"Graphics","text":"field, elayers, eplayers = makefield(layers, ctpixels, layers)\n\nfigure(figsize=(6.4, 5.2))\nshowlayer(first(elayers))\ngca().set_aspect(\"auto\")\nlargeaxis()\nclim(-6, 2)\nsavefig(\"pyplot_pcalayer1.png\")\nclose()","category":"page"},{"location":"graphics/","page":"Graphics","title":"Graphics","text":"(Image: pyplot_pcalayer1.png)","category":"page"},{"location":"graphics/","page":"Graphics","title":"Graphics","text":"figure(figsize=(6.4, 3.2))\nset_cmap(\"viridis\")\nshowlayer(first(eplayers))\nlargeaxis()\nworldwide()\nclim(-6, 2)\nsavefig(\"pyplot_gpcalayer1.png\")\nclose()","category":"page"},{"location":"graphics/","page":"Graphics","title":"Graphics","text":"(Image: pyplot_gpcalayer1.png)","category":"page"},{"location":"graphics/","page":"Graphics","title":"Graphics","text":"At the same time, we may check the Mikrubi field just obtained visually in RGB space (skewed by f = tiedrank in showfield for better image representation). Parts of China are dyed different colors, and the pattern does coincide with our knowledge.","category":"page"},{"location":"graphics/","page":"Graphics","title":"Graphics","text":"figure(figsize=(6.4, 5.2))\nshowfield(field, first(layers))\ngca().set_aspect(\"auto\")\nlargeaxis()\nsavefig(\"pyplot_field.png\")\nclose()","category":"page"},{"location":"graphics/","page":"Graphics","title":"Graphics","text":"(Image: pyplot_field.png)","category":"page"},{"location":"graphics/#Illustrating-the-predictions","page":"Graphics","title":"Illustrating the predictions","text":"","category":"section"},{"location":"graphics/","page":"Graphics","title":"Graphics","text":"Finally it is the fitting and the predictions. Since the model here is in high dimensionality beyond imagination, we turn to check the images of the predictions. Analogously, under the same clim values, the predicted regional distribution (geodist) and the predicted global distribution (ggeodist) are identical over their overlapping area. Using graphics, we can confirm that everything is in accordance with expectation.","category":"page"},{"location":"graphics/","page":"Graphics","title":"Graphics","text":"ctlist = readlist(ctlistpath)\nmodel = fit(field, ctlist)\ngeodist = predict(elayers, model)\n\nfigure(figsize=(6.4, 5.2))\nset_cmap(\"CMRmap\")\nshowlayer(geodist, f = x -> x ^ 0.35)\ngca().set_aspect(\"auto\")\nlargeaxis()\nclim(0, 0.45)\nsavefig(\"pyplot_geodist.png\")\nclose()","category":"page"},{"location":"graphics/","page":"Graphics","title":"Graphics","text":"(Image: pyplot_geodist.png)","category":"page"},{"location":"graphics/","page":"Graphics","title":"Graphics","text":"ggeodist = predict(eplayers, model)\n\nfigure(figsize=(6.4, 3.2))\nset_cmap(\"CMRmap\")\nshowlayer(ggeodist, f = x -> x ^ 0.35)\nlargeaxis()\nworldwide()\nclim(0, 0.45)\nsavefig(\"pyplot_ggeodist.png\")\nclose()","category":"page"},{"location":"graphics/","page":"Graphics","title":"Graphics","text":"(Image: pyplot_ggeodist.png)","category":"page"},{"location":"#Mikrubi.jl","page":"Home","title":"Mikrubi.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Mikrubi","category":"page"},{"location":"#Mikrubi","page":"Home","title":"Mikrubi","text":"Mikrubi.jl\n\n(Image: Documentation) (Image: Documentation) (Image: CI) (Image: Codecov) (Image: Aqua.jl Quality Assurance) (Image: Mikrubi Downloads)\n\nMikrubi: a model for species distributions using region-based records\n\nMany species occurrence records from specimens and publications are based on regions such as administrative units (thus sometimes called counties in the codes). These region-based records are accessible and dependable, and sometimes they are the only available data source; however, few species distribution models accept such data as direct input. In Yang et al. (2023), we present a method named Mikrubi for robust prediction of species distributions from region-based occurrence data. This is the Julia package implementing the algorithms. \n\nInstallation\n\nMikrubi.jl currently requires Julia v1.7.0 or higher. This registered package can be installed inside the Julia REPL by typing\n\n]add Mikrubi\n\nInput data requirements\n\nTo estimate the fine-scale distribution of a species using its presence or absence in each region, the package generally requires three types of input data: \n\nA map describing the shapes of all regions as polygons. For many countries or regions, such an administrative partition map can be found from Database of Global Administrative Areas (accessible via GADM.jl, see examples/prinsepia/jui.jl). Specifically for China, the correct county-level shapefile is available from National Platform of Common Geospatial Information Services and Gaode Map Open Platform.\nRaster layers of climatic factors of the same size, shape, and resolution. A commonly used dataset is WorldClim (accessible via RasterDataSources.jl). \nA list of regions occupied by the species. \n\nWorkflow\n\nA typical workflow of the package resembles the following lines, where shppath refers to the path to the map file, climpath refers to the directory path to the raster files, and ctlistpath refers to the path to the list containing lines of integer identifiers representing the regions.\n\nusing Mikrubi\nshptable = readshape(shppath)\nlayers = readlayers(climpath)\nctlist = readlist(ctlistpath)\nfield, ylayers = makefield(layers, shptable)\nmodel = fit(field, ctlist)\ngeodist = predict(ylayers, model)\nwritelayer(\"path/to/output/geodist.tif\", geodist)\n\nCitation\n\nAn introduction of this package and the model it implements has been published on Ecography (10.1111/ecog.06283).\n\nThank Michael Krabbe Borregaard @mkborregaard and Rafael Schouten @rafaqz for reviewing the code and the manuscript and giving greatly constructive opinions!\n\nIf you apply the package or the model in your research, please cite them via the paper above or as the following after substituting the version:\n\nYang, Y.-C., Zhang, Q. and Chen, Z.-D. 2023. Mikrubi: a model for species distributions using region-based records. â€“ Ecography 2023: e06283 (ver. 1.3.2).\n\nThe equivalent BibTeX file for citation is available at CITATION.bib. You may also import this file or the following BibTeX code block to your reference management software.\n\n@article{Mikrubi2023,\n\tauthor = {Yang, Yu-Chang and Zhang, Qian and Chen, Zhi-Duan},\n\ttitle = {Mikrubi: a model for species distributions using region-based records},\n\tjournal = {Ecography},\n\tyear = {2023},\n\tvolume = {2023},\n\tpages = {e06283},\n\tdoi = {https://doi.org/10.1111/ecog.06283},\n\turl = {https://onlinelibrary.wiley.com/doi/abs/10.1111/ecog.06283},\n\teprint = {https://onlinelibrary.wiley.com/doi/pdf/10.1111/ecog.06283},\n}\n\nPatch to the Ecography paper\n\nDue to an update of GADM.jl on May 16, 2023 which fetches GADM data v4.1 rather than v3.6, the district-level map of Nepal now has index 3 (no longer 1 as in the paper). The corresponding line in the code example from the paper (see also jui.jl) should be changed to\n\nshptable = readshape(shppath, 3) # District-level\n\n\n\n\n\n","category":"module"},{"location":"#A-workflow-example","page":"Home","title":"A workflow example","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"We take Allium wallichii in China as an example. For more details, please check examples/alliwalli/workflow.jl; for the graphic representation of the variables, please visit Graphics).","category":"page"},{"location":"","page":"Home","title":"Home","text":"julia> using Mikrubi\n\njulia> shptable = readshape(shppath)\nLayer: counties\n  Geometry 0 (): [wkbPolygon], POLYGON ((99.994226 ...), ...\n     Field 0 (id): [OFTInteger64], 2367, 2368, 2369, 2370, 2371, 2372, 2373, ...\n     Field 1 (provinceid): [OFTInteger64], 53, 53, 53, 53, 53, 53, 53, 53, ...\n     Field 2 (cityid): [OFTInteger64], 5305, 5305, 5305, 5305, 5305, 5323, ...\n     Field 3 (cocode): [OFTString], 530524, 530523, 530502, 530521, 530522, ...\n     Field 4 (coshname): [OFTString], æ˜Œå®åŽ¿, é¾™é™µåŽ¿, éš†é˜³åŒº, æ–½ç”¸åŽ¿, è…¾å†²åŽ¿, æ¥šé›„å¸‚, å¤§å§šåŽ¿, ...\n...\n Number of Fields: 14\n\njulia> layers = readlayers(climpath)\n[ Info: 19 files \"wc2.0_bio_10m_*.tif\" recognized in the directory, where * = 01, 02, 03, 04, 05, 06, 07, 08, 09, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19.\nRasterStack with dimensions:\n  X Projected{Float64} LinRange{Float64}(-180.0, 179.833, 2160) ForwardOrdered Regular Intervals crs: WellKnownText,\n  Y Projected{Float64} LinRange{Float64}(89.8333, -90.0, 1080) ReverseOrdered Regular Intervals crs: WellKnownText,\n  Band Categorical{Int64} 1:1 ForwardOrdered\nand 19 layers:\n  :wc2.0_bio_10m_01 Float64 dims: X, Y, Band (2160Ã—1080Ã—1)\n  :wc2.0_bio_10m_02 Float64 dims: X, Y, Band (2160Ã—1080Ã—1)\n  :wc2.0_bio_10m_03 Float64 dims: X, Y, Band (2160Ã—1080Ã—1)\n  :wc2.0_bio_10m_04 Float64 dims: X, Y, Band (2160Ã—1080Ã—1)\n  :wc2.0_bio_10m_05 Float64 dims: X, Y, Band (2160Ã—1080Ã—1)\n  :wc2.0_bio_10m_06 Float64 dims: X, Y, Band (2160Ã—1080Ã—1)\n  :wc2.0_bio_10m_07 Float64 dims: X, Y, Band (2160Ã—1080Ã—1)\n  :wc2.0_bio_10m_08 Float64 dims: X, Y, Band (2160Ã—1080Ã—1)\n  :wc2.0_bio_10m_09 Float64 dims: X, Y, Band (2160Ã—1080Ã—1)\n  :wc2.0_bio_10m_10 Float64 dims: X, Y, Band (2160Ã—1080Ã—1)\n  :wc2.0_bio_10m_11 Float64 dims: X, Y, Band (2160Ã—1080Ã—1)\n  :wc2.0_bio_10m_12 Float64 dims: X, Y, Band (2160Ã—1080Ã—1)\n  :wc2.0_bio_10m_13 Float64 dims: X, Y, Band (2160Ã—1080Ã—1)\n  :wc2.0_bio_10m_14 Float64 dims: X, Y, Band (2160Ã—1080Ã—1)\n  :wc2.0_bio_10m_15 Float64 dims: X, Y, Band (2160Ã—1080Ã—1)\n  :wc2.0_bio_10m_16 Float64 dims: X, Y, Band (2160Ã—1080Ã—1)\n  :wc2.0_bio_10m_17 Float64 dims: X, Y, Band (2160Ã—1080Ã—1)\n  :wc2.0_bio_10m_18 Float64 dims: X, Y, Band (2160Ã—1080Ã—1)\n  :wc2.0_bio_10m_19 Float64 dims: X, Y, Band (2160Ã—1080Ã—1)\n\njulia> ctlist = readlist(ctlistpath)\n46-element Array{Int64,1}:\n  568\n  162\n  364\n  ...\n  233\n 2768\n 2770\n\njulia> field, ylayers = makefield(layers, shptable);\n\njulia> field\nMikrubi Field: geo_dim = 2, env_dim = 3, 62716 pixels, and 2893 counties\n\njulia> ylayers\nRasterStack with dimensions:\n  X Projected{Float64} LinRange{Float64}(-180.0, 179.833, 2160) ForwardOrdered Regular Intervals crs: WellKnownText,\n  Y Projected{Float64} LinRange{Float64}(89.8333, -90.0, 1080) ReverseOrdered Regular Intervals crs: WellKnownText,\n  Band Categorical{Int64} 1:1 ForwardOrdered\nand 3 layers:\n  :pca1 Float64 dims: X, Y, Band (2160Ã—1080Ã—1)\n  :pca2 Float64 dims: X, Y, Band (2160Ã—1080Ã—1)\n  :pca3 Float64 dims: X, Y, Band (2160Ã—1080Ã—1)\n\njulia> model = fit(field, ctlist)\n[ Info: Now minimizing the opposite likelihood function...\nIter     Function value    âˆš(Î£(yáµ¢-yÌ„)Â²)/n\n------   --------------    --------------\n     0     4.171830e+04     2.450473e+02\n * time: 0.01399993896484375\n   500     1.833867e+02     9.325053e-02\n * time: 2.998000144958496\n  1000     1.470935e+02     1.524631e-01\n * time: 4.9700000286102295\n  1500     1.388932e+02     4.105145e-02\n * time: 6.976000070571899\n  2000     1.273631e+02     2.085092e-02\n * time: 8.812000036239624\n  2500     1.266571e+02     9.378015e-05\n * time: 10.5239999294281\n[ Info: Maximized log-likeliness: -126.65599400745549\nMikrubiModel{Float64}(3, [1.4842288152354197, -1.3603311815698715, -0.38761691866210646, 1.1231074177981228, 1.2090116395112087, -0.1033479618173679, 14.747024521778938, -14.878922083170924, 11.97056752230023, 30.299436373642205])\n\njulia> geodist = predict(ylayers, model)\n2160Ã—1080Ã—1 Raster{Float64,3} prob with dimensions:\n  X Projected{Float64} LinRange{Float64}(-180.0, 179.833, 2160) ForwardOrdered Regular Intervals crs: WellKnownText,\n  Y Projected{Float64} LinRange{Float64}(89.8333, -90.0, 1080) ReverseOrdered Regular Intervals crs: WellKnownText,\n  Band Categorical{Int64} 1:1 ForwardOrdered\nextent: Extent(X = (-180.0, 179.99999999999997), Y = (-90.0, 90.0), Band = (1, 1))\nmissingval: -1.7e308\ncrs: GEOGCS[\"WGS 84\",DATUM[\"WGS_1984\",SPHEROID[\"WGS 84\",6378137,298.257223563,AUTHORITY[\"EPSG\",\"7030\"]],AUTHORITY[\"EPSG\",\"6326\"]],PRIMEM[\"Greenwich\",0,AUTHORITY[\"EPSG\",\"8901\"]],UNIT[\"degree\",0.0174532925199433,AUTHORITY[\"EPSG\",\"9122\"]],AXIS[\"Latitude\",NORTH],AXIS[\"Longitude\",EAST],AUTHORITY[\"EPSG\",\"4326\"]]\nvalues: [:, :, 1]\n           89.8333   89.6667   89.5      89.3333   89.1667   â€¦  -89.3333   -89.5      -89.6667   -89.8333   -90.0\n -180.0    -1.7e308  -1.7e308  -1.7e308  -1.7e308  -1.7e308      -1.7e308   -1.7e308   -1.7e308   -1.7e308   -1.7e308\n -179.833  -1.7e308  -1.7e308  -1.7e308  -1.7e308  -1.7e308      -1.7e308   -1.7e308   -1.7e308   -1.7e308   -1.7e308\n -179.667  -1.7e308  -1.7e308  -1.7e308  -1.7e308  -1.7e308      -1.7e308   -1.7e308   -1.7e308   -1.7e308   -1.7e308\n -179.5    -1.7e308  -1.7e308  -1.7e308  -1.7e308  -1.7e308      -1.7e308   -1.7e308   -1.7e308   -1.7e308   -1.7e308\n -179.333  -1.7e308  -1.7e308  -1.7e308  -1.7e308  -1.7e308  â€¦   -1.7e308   -1.7e308   -1.7e308   -1.7e308   -1.7e308\n -179.167  -1.7e308  -1.7e308  -1.7e308  -1.7e308  -1.7e308      -1.7e308   -1.7e308   -1.7e308   -1.7e308   -1.7e308\n -179.0    -1.7e308  -1.7e308  -1.7e308  -1.7e308  -1.7e308      -1.7e308   -1.7e308   -1.7e308   -1.7e308   -1.7e308\n -178.833  -1.7e308  -1.7e308  -1.7e308  -1.7e308  -1.7e308      -1.7e308   -1.7e308   -1.7e308   -1.7e308   -1.7e308\n    â‹®                                               â‹®        â‹±                                                â‹®\n  178.5    -1.7e308  -1.7e308  -1.7e308  -1.7e308  -1.7e308  â€¦   -1.7e308   -1.7e308   -1.7e308   -1.7e308   -1.7e308\n  178.667  -1.7e308  -1.7e308  -1.7e308  -1.7e308  -1.7e308      -1.7e308   -1.7e308   -1.7e308   -1.7e308   -1.7e308\n  178.833  -1.7e308  -1.7e308  -1.7e308  -1.7e308  -1.7e308      -1.7e308   -1.7e308   -1.7e308   -1.7e308   -1.7e308\n  179.0    -1.7e308  -1.7e308  -1.7e308  -1.7e308  -1.7e308      -1.7e308   -1.7e308   -1.7e308   -1.7e308   -1.7e308\n  179.167  -1.7e308  -1.7e308  -1.7e308  -1.7e308  -1.7e308      -1.7e308   -1.7e308   -1.7e308   -1.7e308   -1.7e308\n  179.333  -1.7e308  -1.7e308  -1.7e308  -1.7e308  -1.7e308  â€¦   -1.7e308   -1.7e308   -1.7e308   -1.7e308   -1.7e308\n  179.5    -1.7e308  -1.7e308  -1.7e308  -1.7e308  -1.7e308      -1.7e308   -1.7e308   -1.7e308   -1.7e308   -1.7e308\n  179.667  -1.7e308  -1.7e308  -1.7e308  -1.7e308  -1.7e308      -1.7e308   -1.7e308   -1.7e308   -1.7e308   -1.7e308\n  179.833  -1.7e308  -1.7e308  -1.7e308  -1.7e308  -1.7e308      -1.7e308   -1.7e308   -1.7e308   -1.7e308   -1.7e308\n\njulia> writelayer(\"path/to/output/geodist.tif\", geodist)\n","category":"page"},{"location":"#Outline-of-[Manual](@ref)","page":"Home","title":"Outline of Manual","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Pages = [\n    \"manual.md\",\n]\nDepth = 3","category":"page"},{"location":"#Outline-of-[Graphics](@ref)","page":"Home","title":"Outline of Graphics","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Pages = [\n    \"graphics.md\",\n]\nDepth = 4","category":"page"},{"location":"#main-index","page":"Home","title":"Index","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"","category":"page"}]
}
