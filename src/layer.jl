# src/layer.jl

"""
	colmatrix(vector::AbstractVector) :: AbstractMatrix
	colmatrix(matrix::AbstractMatrix) :: AbstractMatrix

Return a one-column matrix if the argument is a vector, or the matrix itself 
if the argument is already a matrix.
"""
colmatrix(vector::AbstractVector) = repeat(vector, 1, 1)
colmatrix(matrix::AbstractMatrix) = matrix

"""
	allsame(a::AbstractVector) :: Bool

Return `true` if all elements from `a` are identical, or otherwise `false`. 
An error is thrown if the vector `a` is empty.

# Examples
```julia
julia> allsame([1, 1, 2])
false

julia> allsame([1, 1, 1])
true

julia> allsame([1])
true

julia> allsame([])
ERROR: BoundsError: attempt to access 0-element Array{Any,1} at index [1]
Stacktrace:
 [1] getindex at .\\array.jl:787 [inlined]
 [2] allsame(::Array{Any,1}) at .\\REPL[9]:1
 [3] top-level scope at REPL[20]:1
```
"""
allsame(a::AbstractVector) = all(a .== first(a))

"""
	sortfilenames!(filenames::AbstractVector{<:AbstractString})

Sort `filenames` in place according to the order of the distinctive parts 
among them. If all of the distinctive parts are decimal numerals, they are 
sorted as integers.

# Examples
```julia
julia> sortfilenames!(["bio_9.tif", "bio_10.tif", "bio_1.tif"])
[ Info: 3 files "bio_*.tif" recognized in the directory, where * = 1, 9, 10.
3-element Array{String,1}:
 "bio_1.tif"
 "bio_9.tif"
 "bio_10.tif"

julia> sortfilenames!(["bio_09.tif", "bio_10.tif", "bio_01.tif"])
[ Info: 3 files "bio_*.tif" recognized in the directory, where * = 01, 09, 10.
3-element Array{String,1}:
 "bio_01.tif"
 "bio_09.tif"
 "bio_10.tif"
```
"""
function sortfilenames!(filenames::AbstractVector{<:AbstractString})
	if length(filenames) == 0
		error("No file recognized in the directory!")
	elseif length(filenames) == 1
		@info textwrap("Only one file \"$(splitpath(filenames[1])[end])\" 
			recognized in the directory.")
		return
	end
	s = 1
	while allsame([fn[s] for fn = filenames])
		s += 1
	end
	t = 0
	while allsame([fn[end-t] for fn = filenames])
		t += 1
	end
	fileids = [fn[s:end-t] for fn = filenames]
	perm = sortperm(fileids)
	try
		perm = sortperm(parse.(Int, fileids))
	catch ; end
	@info textwrap("$(length(filenames)) files 
		\"$(splitpath(filenames[1][1:s-1])[end])*$(filenames[1][end-t+1:end])\"
		recognized in the directory, where * = $(join(fileids[perm], ", ")).")
	filenames .= filenames[perm]
	filenames
end

"""
	readlayers(dir::AbstractString; extset=nothing) :: RasterStack

Read all raster layers from the directory `dir` as a `RasterStack`. 

`extset` describes possible extensions of raster files (e.g., `Set(".tif")`, 
or `[".tiff"]`; see also [`readshape`](@ref)). By setting `extset` to 
`nothing`, the extension filtering is not processed, i.e., all files are 
regarded as raster files. 
"""
function readlayers(dir::AbstractString; extset=nothing)
	filenames = filterext(dir, extset)
	sortfilenames!(filenames)
	layers = RasterStack(filenames)
	keyz = keys(layers)
	return RasterStack(map(key -> Float64.(layers[key]), keyz); name=keyz)
		# for better numerical stability
end

"""
	writelayer(path::AbstractString, layer::Raster) :: Nothing

Write `layer` to the disk at `path`. Alias for `GeoArrays.write!`.
"""
writelayer(path::AbstractString, layer::Raster) = (write(path, layer); return)

"""
	writelayers(paths::AbstractVector{<:AbstractString}, 
		layers::RasterStack) :: Nothing
	writelayers(pathformula::AbstractString, layers::RasterStack) :: Nothing

Write `layers` to `paths` respondingly, or a series of paths generated by the
`pathformula` where an asterisk is used for wildcard and replaced by numbers.
"""
function writelayers(paths::AbstractVector{<:AbstractString}, 
		layers::RasterStack)
	length(paths) != length(layers) &&
		error("`paths` and `layers` must have the same length!")
	for (path, layer) = zip(paths, values(layers))
		writelayer(path, layer)
	end
end
function writelayers(pathformula::AbstractString, layers::RasterStack)
	occursin("*", pathformula) ||
		error("`pathformula` must contain an asterisk (\"`*`\") as wildcard!")
	for (i, layer) = enumerate(values(layers))
		path = replace(pathformula, "*" => i)
		writelayer(path, layer)
	end
end

"""
	masklayers!(layers::RasterStack, ctpixels::CtPixels) :: RasterStack

Mask the `layers` in a way that only pixels present in `ctpixels` are kept, 
while all other uncovered pixels are set to a missing value.
"""
function masklayers!(layers::RasterStack, ctpixels::CtPixels)
	miss = boolmask(layers)
	miss[getpixels(ctpixels)] .= false
	for layer = values(layers)
		layer[miss] .= missingval(layer)
	end
	layers
end

"""
	extractlayers(layers::RasterStack) :: Tuple{Matrix, Vector{Int}}

Extract the non-missing pixels from `layers`, and combine them into a matrix, 
whose rows representing pixels and columns representing variables.

`extractlayers` is the inverse function of [`makelayers`](@ref).
"""
function extractlayers(layers::RasterStack)
	nonmiss = boolmask(layers)
	hcat(values(layers[nonmiss])...), findall(nonmiss[:])
end

"""
	emptylayer!(grid::Raster) :: Raster

Fill the `grid` with missing values in place.
"""
emptylayer!(grid::Raster) = (grid .= missingval(grid); grid)

"""
	emptylayer(grid::Raster) :: Raster

Create a new `Raster` full of missing values from the shape of `grid`.
"""
emptylayer(grid::Raster) = emptylayer!(copy(grid))

"""
	emptylayers(grid::Raster, m::Int) :: RasterStack

Create a `RasterStack` with `m` empty `Raster`s (full of missing values) from 
the shape of `grid`.
"""
emptylayers(grid::Raster, m::Int) = 
	RasterStack(Tuple(emptylayer(grid) for _ = 1:m); name=string.("pca", 1:m))

"""
	makelayers(matrix::AbstractMatrix, idx::AbstractVector, grid::Raster) 
		:: RasterStack

Make a `RasterStack` from the `grid` and values in columns of `matrix`.

For making a `Raster` from a column vector, see [`makelayer`](@ref).

`makelayers` is the inverse function of [`extractlayers`](@ref).
"""
function makelayers(matrix::AbstractMatrix, idx::AbstractVector, grid::Raster)
	npixel, mvar = size(matrix)
	npixel == length(idx) || throw(DimensionMismatch(
		"The row number of `matrix` is not equal to the length of `idx`!"))
	layers = emptylayers(grid, mvar)
	for (i, layer) = enumerate(values(layers))
		layer[idx] .= matrix[:, i]
	end
	layers
end

"""
	makelayer(vector::AbstractVector, idx::AbstractVector, grid::Raster)

Make a `Raster` from the `grid` and values in `vector`. 

For making a `RasterStack` from a matrix, see [`makelayers`](@ref).
"""
makelayer(vector::AbstractVector, idx::AbstractVector, grid::Raster) =
	first(makelayers(colmatrix(vector), idx, grid))

"""
	dftraverse!(beststate, bestscore, state, score, depth, maxdepth, 
		incompat, scoremat) :: Nothing

Find the index combination that
- firstly containing as many indices as possible, and
- secondly with the lowest pairwise sum from submatrix of `scoremat`,
such that no indices `i` and `j` coexist as long as `incompat[i][j] == true`.

The result is stored as the only element of `beststate`, with its score
decided by the two criteria above stored as the only element of `bestscore`.

# Example
```julia
julia> beststate = Vector(undef, 1);

julia> bestscore = [(0, 0.0)];

julia> dftraverse!(beststate, bestscore, Int[], (0, 0.0), 1, 3,
           Bool[0 0 1; 0 0 0; 1 0 0],
           [0.0 0.6 0.3; 0.6 0.0 0.9; 0.3 0.9 0.0]);

julia> beststate
1-element Array{Any,1}:
 [1, 2]

julia> bestscore
1-element Array{Tuple{Int64,Float64},1}:
 (2, -0.6)
```
"""
function dftraverse!(beststate, bestscore, state, score, depth, maxdepth, 
		incompat, scoremat)
	if depth > maxdepth	
		if score > bestscore[1]
			bestscore[1] = score
			beststate[1] = state
		end
		return
	end
	if ! any(incompat[state, depth])
		dftraverse!(beststate, bestscore, vcat(state, depth), 
			score .+ (1, -sum(scoremat[state, depth])), depth + 1, maxdepth,
			incompat, scoremat)
	end
	dftraverse!(beststate, bestscore, state, score, depth + 1, maxdepth,
		incompat, scoremat)
end

"""
	selectvars(matrix::Matrix, rabsthres=0.8) :: Vector{Int}

Select as many variables as possible from `matrix` such that no pairwise
Pearson coefficient among them exceeds `rabsthres` and their sum is minimal.

# Example
```julia
julia> selectvars([1. 4. 7.; 2. 5. 8.; 3. 9. 27.], rabsthres=0.9)
2-element Array{Int64,1}:
 1
 3
```
"""
function selectvars(matrix::Matrix; rabsthres=0.8)
	rabsmat = abs.(cor(matrix, dims=1))
	incompat = rabsmat .> rabsthres
	beststate = Vector(undef, 1)
	bestscore = [(0, zero(eltype(matrix)))]
	dftraverse!(beststate, bestscore, Int[], bestscore[1], 1, size(matrix, 2),
		incompat, rabsmat)
	beststate[1]
end

# """
# 	rowmeanstd(smatrix::Matrix) :: Tuple{Matrix, Matrix}
# 
# Compute the mean and standard variation of a matrix by its rows.
# """
# function rowmeanstd(smatrix::Matrix)
# 	n = size(smatrix, 1)
# 	mean = sum(smatrix, dims=1) ./ n
# 	std = sqrt.(sum((smatrix .- mean) .^ 2, dims=1) ./ (n-1))
# 	return mean, std
# end

"""
	princompvars(smatrix::Matrix; nprincomp=3) :: Tuple{Vector, Matrix}

Perform principal component analysis on `smatrix` whose columns represents
variables, and combines the `nprincomp` principal components into a matrix, and
returns the result matrix as well as the affine transformation
`(colmean, projwstd)`, such that
the result matrix == `(smatrix .- colmean) * projwstd`.
"""
function princompvars(smatrix::AbstractMatrix; nprincomp=3)
	nprincomp > MAXPCADIM && 
		@warn textwrap("It is strongly recommended that no more than four
			principal components are used for Mikrubi, or parameter space would
			be highly ill-conditioned!")
	colmean = mean(smatrix, dims=1)
	colstd = std(smatrix, dims=1)
	# colmean, colstd = rowmeanstd(smatrix)
	minimum(colstd) .<= 1e-11 &&
		error(textwrap("Some variable among the layers has a very small
			deviation (in other words, is (nearly) constant), which directly
			leads to ill condition of succeeding calculations."))
	smatrix01 = (smatrix .- colmean) ./ colstd
	pca = MultivariateStats.fit(MultivariateStats.PCA, 
		smatrix01', maxoutdim=nprincomp)
	pcadim = size(pca)[2]
	pcadim < nprincomp &&
		@warn textwrap("Only $(size(pca)[2]) principal component(s) (less than
			`nprincomp` = $nprincomp) is/are used to expressed the selected
			layers in the principal component analysis.")
	proj = MultivariateStats.projection(pca)
	projwstd = proj ./ colstd[:]
	return colmean, projwstd
end

"""
	DimLower

	DimLower()

A container for transformation used in `makefield`, working as a function. If 
it is new (`new=true`), the parameters (`colid`, `colmean`, and `projwstd`) 
are computed when it is applied on a `RasterStack`. 
"""
mutable struct DimLower{T<:AbstractFloat}
	new::Bool
	colid::Vector{Int}
	colmean::Matrix{T}
	projwstd::Matrix{T}
	DimLower(layers::RasterStack) = new{eltype(first(layers))}(true)
end

function (f::DimLower)(layers::RasterStack; rabsthres=0.8, nprincomp=3)
	matrix, idx = extractlayers(layers)
	f.new && (f.colid = selectvars(matrix; rabsthres=rabsthres))
	smatrix = matrix[:, f.colid]
	f.new && 
		((f.colmean, f.projwstd) = princompvars(smatrix; nprincomp=nprincomp))
	ematrix = (smatrix .- f.colmean) * f.projwstd
	f.new = false
	elayers = makelayers(ematrix, idx, first(layers))
	return idx, ematrix, elayers
end

"""
	makefield(layers::RasterStack, ctpixels::CtPixels; 
		rabsthres=0.8, nprincomp=3) :: Tuple{MikrubiField, RasterStack}
	makefield(layers::RasterStack, ctpixels::CtPixels, 
		players::RasterStack; rabsthres=0.8, nprincomp=3)
			:: Tuple{MikrubiField, RasterStack, RasterStack}
	makefield(layers::RasterStack, shptable; rabsthres=0.8, nprincomp=3)
		:: Tuple{MikrubiField, RasterStack}
	makefield(layers::RasterStack, shptable, players::RasterStack; 
		rabsthres=0.8, nprincomp=3)
			:: Tuple{MikrubiField, RasterStack, RasterStack}

Create a `MikrubiField` as well as processed variable layers from `layers`  
and `shptable` or `ctpixels`, by 
0. (rasterizing the `shptable` to `ctpixels` using `rasterize`,) 
1. masking the `layers` with `ctpixels` (using `Mikrubi.masklayers!`), 
2. extracting non-missing pixels from `layers` (using `Mikrubi.extractlayers`),
3. selecting less correlated variables (using `Mikrubi.selectvars`), and 
4. doing the principal component analysis (using `Mikrubi.princompvars`).

# Optional keyword arguments

- `rabsthres`: threshold of collinearity.
Absolute value of Pearson correlation efficient greater than this threshold 
is identified as collinearity and the two variables are thus incompatible. 
- `nprincomp`: expected number of principal components of the variables.

# Notes about `players`

When `players` is present in the argument list, raster layers it contains 
experience the same process including subsetting, selecting, and taking 
principal components, and results are packed and returned in the third place. 
User must assure that `players` has the same length as `layers`, and 
their elements are corresponding in order. This would be useful when the 
prediction is in another geographic range or at another time.
"""
makefield(layers::RasterStack, ctpixels::CtPixels; 
	rabsthres=0.8, nprincomp=3) = 
		_makefield(layers, ctpixels, rabsthres, nprincomp)[1:2]
function makefield(layers::RasterStack, ctpixels::CtPixels, 
		players::RasterStack; rabsthres=0.8, nprincomp=3)
	length(layers) == length(players) || 
		error("`players` must have the same length as `layers`!")
	field, elayers, dimlower = 
		_makefield(layers, ctpixels, rabsthres, nprincomp)
	eplayers = last(dimlower(players))
	return field, elayers, eplayers
end
makefield(layers::RasterStack, shptable; rabsthres=0.8, nprincomp=3) = 
	makefield(layers, rasterize(shptable, first(layers)); 
		rabsthres=rabsthres, nprincomp=nprincomp)
makefield(layers::RasterStack, shptable, players::RasterStack; 
	rabsthres=0.8, nprincomp=3) = 
		makefield(layers, rasterize(shptable, first(layers)), players; 
			rabsthres=rabsthres, nprincomp=nprincomp)

function _makefield(layers::RasterStack, ctpixels::CtPixels, 
		rabsthres, nprincomp)
	layers = deepcopy(layers)
	masklayers!(layers, ctpixels)
	dimlower = DimLower(layers)
	idx, ematrix, elayers = 
		dimlower(layers; rabsthres=rabsthres, nprincomp=nprincomp)
	field = buildfield(ctpixels, idx, ematrix, first(layers))
	return field, elayers, dimlower
end

"""
	dimpoints(grid::Raster) :: DimPoints

Create a `DimensionalData.DimPoints` from `grid` after shifting all its 
dimension loci to `Center()`. Similar to `GeoArrays.coords`.
"""
function dimpoints(grid::Raster)
	ds = map(dims(grid)) do d
		DD.maybeshiftlocus(DD.Center(), d)
	end
	return DD.DimPoints(set(grid, ds))
end

"""
	centercoords(dp::DimPoints, ci::CartesianIndices, idx::Int) 
		:: Tuple{AbstractFloat, AbstractFloat}

Get center coordinates of a grid cell indexed by `idx` in a `Raster`.
"""
function centercoords(grid::Raster, idx::Int)
	dp = dimpoints(grid)
	ci = CartesianIndices(grid)
	return dp[ci[idx]][1:2]
end
centercoords(dp::DD.DimPoints, ci::CartesianIndices, idx::Int) = 
	dp[ci[idx]][1:2]

"""
	buildfield(ctpixels::CtPixels, idx::Vector, 
		projmat::Matrix, grid::Raster) :: MikrubiField

Construct a `MikrubiField` from `ctpixels`, `idx`, `projmat`, and `grid`. Used in 
[`makefield`](@ref).
"""
function buildfield(ctpixels::CtPixels, idx::AbstractVector, 
		projmat::AbstractMatrix, grid::Raster)
	ctids = getcounties(ctpixels)
	npixel = length(ctids)
	mvar = size(projmat, 2)
	revidx = Dict(idx .=> 1:length(idx))
	locs = Matrix{eltype(grid.dims[1])}(undef, npixel, 2)
	vars = Matrix{eltype(projmat)}(undef, npixel, mvar)
	found = trues(npixel)
	dp = dimpoints(grid)
	ci = CartesianIndices(grid)
	for i = 1:npixel
		coord = getpixel(ctpixels, i)
		if haskey(revidx, coord)
			locs[i, :] .= centercoords(dp, ci, coord)
			vars[i, :] .= projmat[revidx[coord], :]
		else
			found[i] = false
		end
	end
	sumfound = sum(found)
	ratiofound = sumfound / npixel
	0.9 < ratiofound < 1 &&
		@info textwrap("Among the $npixel pixels, $(npixel-sumfound) 
			($(@sprintf("%.1f", 100 * (1 - ratiofound)))%) is/are discarded 
			for lacking values.")
	ratiofound <= 0.9 &&
		@warn textwrap("Among the $npixel pixels, $(npixel-sumfound) 
			($(@sprintf("%.1f", 100 * (1 - ratiofound)))%) is/are discarded 
			for lacking values!")
	MikrubiField(ctids[found], locs[found, :], vars[found, :])
end
