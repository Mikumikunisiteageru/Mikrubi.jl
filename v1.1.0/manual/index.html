<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Manual · A Manual for Mikrubi</title><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.039/juliamono-regular.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.11/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><script src="../../copy.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../">A Manual for Mikrubi</a></span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li class="is-active"><a class="tocitem" href>Manual</a><ul class="internal"><li><a class="tocitem" href="#Reading-and-writing"><span>Reading and writing</span></a></li><li><a class="tocitem" href="#Rasterizing-a-shapefile"><span>Rasterizing a shapefile</span></a></li><li><a class="tocitem" href="#makefield"><span>Processing the raster layers</span></a></li><li><a class="tocitem" href="#The-Mikrubi-core"><span>The Mikrubi core</span></a></li></ul></li><li><a class="tocitem" href="../graphics/">Graphics</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Manual</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Manual</a></li></ul></nav><div class="docs-right"><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Manual"><a class="docs-heading-anchor" href="#Manual">Manual</a><a id="Manual-1"></a><a class="docs-heading-anchor-permalink" href="#Manual" title="Permalink"></a></h1><ul><li><a href="#Manual">Manual</a></li><li class="no-marker"><ul><li><a href="#Reading-and-writing">Reading and writing</a></li><li class="no-marker"><ul><li><a href="#Reading-and-searching-shapefile">Reading and searching shapefile</a></li><li><a href="#Reading-and-writing-list-file">Reading and writing list file</a></li><li><a href="#Reading-and-writing-raster-layers">Reading and writing raster layers</a></li><li><a href="#Reading-and-writing-Mikrubi-field">Reading and writing Mikrubi field</a></li><li><a href="#Reading-and-writing-Mikrubi-model">Reading and writing Mikrubi model</a></li></ul></li><li><a href="#Rasterizing-a-shapefile">Rasterizing a shapefile</a></li><li><a href="#makefield">Processing the raster layers</a></li><li><a href="#The-Mikrubi-core">The Mikrubi core</a></li><li class="no-marker"><ul><li><a href="#Mikrubi-field">Mikrubi field</a></li><li><a href="#Mikrubi-model">Mikrubi model</a></li><li><a href="#fitfuncm">Fitting a Mikrubi model</a></li><li><a href="#Predicting-from-a-Mikrubi-model">Predicting from a Mikrubi model</a></li><li><a href="#Sampling-counties-in-a-Mikrubi-field">Sampling counties in a Mikrubi field</a></li><li><a href="#Mathematic-functions">Mathematic functions</a></li></ul></li></ul></li></ul><h2 id="Reading-and-writing"><a class="docs-heading-anchor" href="#Reading-and-writing">Reading and writing</a><a id="Reading-and-writing-1"></a><a class="docs-heading-anchor-permalink" href="#Reading-and-writing" title="Permalink"></a></h2><h3 id="Reading-and-searching-shapefile"><a class="docs-heading-anchor" href="#Reading-and-searching-shapefile">Reading and searching shapefile</a><a id="Reading-and-searching-shapefile-1"></a><a class="docs-heading-anchor-permalink" href="#Reading-and-searching-shapefile" title="Permalink"></a></h3><p>Since Mikrubi always reads instead of writes shapefile, only the reading function is offered.</p><article class="docstring"><header><a class="docstring-binding" id="Mikrubi.readshape" href="#Mikrubi.readshape"><code>Mikrubi.readshape</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">readshape(path::AbstractString)</code></pre><p>Reads a shape (&quot;.shp&quot;) file located at <code>path</code>. Alias for <code>Shapefile.Table</code>.</p></div></section></article><p>The function <a href="#Mikrubi.lookup"><code>lookup</code></a> is useful when some attribute (e.g. name or code) of a county is known and the row number of the county in a shapefile is wanted (row number acts as identifiers in the list of occupied counties, see the syntax of <a href="#StatsBase.fit"><code>fit</code></a>). </p><article class="docstring"><header><a class="docstring-binding" id="Mikrubi.lookup" href="#Mikrubi.lookup"><code>Mikrubi.lookup</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">lookup(shptable::Shapefile.Table, column::Symbol, entry)
lookup(shptable::Shapefile.Table, column::Symbol, entries::AbstractArray)</code></pre><p>Finds row(s) in the shapefile table whose <code>column</code> record(s) equal(s) to <code>entry</code> or elements of <code>entries</code>. When the third argument is an array, results are output as an array of the same shape by broadcasting.  </p></div></section></article><h3 id="Reading-and-writing-list-file"><a class="docs-heading-anchor" href="#Reading-and-writing-list-file">Reading and writing list file</a><a id="Reading-and-writing-list-file-1"></a><a class="docs-heading-anchor-permalink" href="#Reading-and-writing-list-file" title="Permalink"></a></h3><p>List of occupied counties can be prepared explicitly in REPL as a vector or a set. Meanwhile, it is also possible to read from or write to disk such a list, especially when the list is generated outside Julia.</p><article class="docstring"><header><a class="docstring-binding" id="Mikrubi.readlist" href="#Mikrubi.readlist"><code>Mikrubi.readlist</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">readlist(path::AbstractString)</code></pre><p>Reads any list of vector from file.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Mikrubi.writelist" href="#Mikrubi.writelist"><code>Mikrubi.writelist</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">writemodel(path::AbstractString, list::Vector)</code></pre><p>Writes any list or vector to file.</p></div></section></article><h3 id="Reading-and-writing-raster-layers"><a class="docs-heading-anchor" href="#Reading-and-writing-raster-layers">Reading and writing raster layers</a><a id="Reading-and-writing-raster-layers-1"></a><a class="docs-heading-anchor-permalink" href="#Reading-and-writing-raster-layers" title="Permalink"></a></h3><p>Climatic factors are downloaded and stored as raster layers. Mikrubi reads such layers by <a href="#Mikrubi.readlayers"><code>readlayers</code></a>, performs principal component analysis on them and returns the results as layers also. When the output layers need to be kept for future use, they can be written to disk using <a href="#Mikrubi.writelayers"><code>writelayers</code></a>. Moreover, when the predicted distribution of species is organized in raster format, it can be saved likewise using <a href="#Mikrubi.writelayer"><code>writelayer</code></a>.</p><article class="docstring"><header><a class="docstring-binding" id="Mikrubi.readlayers" href="#Mikrubi.readlayers"><code>Mikrubi.readlayers</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">readlayers(dir::AbstractString; extset=nothing)</code></pre><p>Returns all raster layers as a vector of <code>GeoArray</code>s from the directory <code>dir</code>. All elements in the vector returned are modifiable, and modifications do not affect the files on the disk. </p><p>By setting <code>extset</code> to a container of extensions (e.g. <code>Set(&quot;.tif&quot;)</code>, or <code>[&quot;.tiff&quot;]</code>), only files ending with its elements are read. Default value is <code>nothing</code>, which means no file extension filtering.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Mikrubi.writelayer" href="#Mikrubi.writelayer"><code>Mikrubi.writelayer</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">writelayer(path::AbstractString, layer::GeoArray)</code></pre><p>Writes <code>layer</code> to the disk at <code>path</code>. Alias for <code>GeoArrays.write!</code>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Mikrubi.writelayers" href="#Mikrubi.writelayers"><code>Mikrubi.writelayers</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">writelayers(paths::Vector{&lt;:AbstractString}, layers::Vector)
writelayers(pathformula::AbstractString, layers::Vector)</code></pre><p>Writes <code>layers</code> to <code>paths</code> respondingly, or a series of paths generated by the <code>pathformula</code> where an asterisk is used for wildcard and replaced by numbers.</p></div></section></article><h4 id="Internal-functions"><a class="docs-heading-anchor" href="#Internal-functions">Internal functions</a><a id="Internal-functions-1"></a><a class="docs-heading-anchor-permalink" href="#Internal-functions" title="Permalink"></a></h4><p>It worths mention that when reading layers from a directory, files are sorted according to their names in a manner similar to the sorting order in Windows OS. Please pay extra attention when two parallel series of raster layers are involved for <a href="#Mikrubi.makefield"><code>makefield</code></a>. </p><article class="docstring"><header><a class="docstring-binding" id="Mikrubi.sortfilenames!" href="#Mikrubi.sortfilenames!"><code>Mikrubi.sortfilenames!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">sortfilenames!(filenames::Vector{&lt;:AbstractString})</code></pre><p>Identifies the distinctive parts among <code>filenames</code>, and sorts <code>filenames</code> according to the order of those parts. If all of the distinctive parts are decimal numerals, they are sorted as integers.</p><p><strong>Examples</strong></p><pre><code class="language-julia hljs">julia&gt; sortfilenames!([&quot;bio_9.tif&quot;, &quot;bio_10.tif&quot;, &quot;bio_1.tif&quot;])
[ Info: Totally 3 raster files recognized in the directory, in the form of bio_*.tif, where asterisk mean 1, 9, 10.
3-element Array{String,1}:
 &quot;bio_1.tif&quot;
 &quot;bio_9.tif&quot;
 &quot;bio_10.tif&quot;

julia&gt; sortfilenames!([&quot;bio_09.tif&quot;, &quot;bio_10.tif&quot;, &quot;bio_01.tif&quot;])
[ Info: Totally 3 raster files recognized in the directory, in the form of bio_*.tif, where asterisk mean 01, 09, 10.
3-element Array{String,1}:
 &quot;bio_01.tif&quot;
 &quot;bio_09.tif&quot;
 &quot;bio_10.tif&quot;</code></pre></div></section></article><p>All layers read are copied (so that they are no longer read-only and linking to the files on disk) and replaced extreme values by <code>missing</code>s. To change this behavior, please refer to the inner function <a href="#Mikrubi.copylayer"><code>Mikrubi.copylayer</code></a>.</p><article class="docstring"><header><a class="docstring-binding" id="Mikrubi.copylayer" href="#Mikrubi.copylayer"><code>Mikrubi.copylayer</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">copylayer(layer::GeoArray; 
	fixmissing=true, verylargebase=1_000_000_000_000)</code></pre><p>Copies a <code>GeoArray</code> layer (so that the matrix is not read-only).</p><p>By setting <code>fixmissing = true</code>, all pixels with absolute values greater than <code>verylargebase</code> (= 10^12 by default) are identified as <code>missing</code>.</p></div></section></article><h3 id="Reading-and-writing-Mikrubi-field"><a class="docs-heading-anchor" href="#Reading-and-writing-Mikrubi-field">Reading and writing Mikrubi field</a><a id="Reading-and-writing-Mikrubi-field-1"></a><a class="docs-heading-anchor-permalink" href="#Reading-and-writing-Mikrubi-field" title="Permalink"></a></h3><p><a href="#Mikrubi.MikrubiField"><code>MikrubiField</code></a> is a specially designed type where the environmental information of pixels and their county identifiers are nested. It may be necessary to save (by <a href="#Mikrubi.writefield"><code>writefield</code></a>) and load (by <a href="#Mikrubi.readfield"><code>readfield</code></a>) a Mikrubi field especially when it is used on multiple species.</p><article class="docstring"><header><a class="docstring-binding" id="Mikrubi.readfield" href="#Mikrubi.readfield"><code>Mikrubi.readfield</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">readfield(path::AbstractString)</code></pre><p>Reads a Mikrubi field from file.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Mikrubi.writefield" href="#Mikrubi.writefield"><code>Mikrubi.writefield</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">writefield(path::AbstractString, field::MikrubiField)</code></pre><p>Writes a Mikrubi field to file.</p></div></section></article><h3 id="Reading-and-writing-Mikrubi-model"><a class="docs-heading-anchor" href="#Reading-and-writing-Mikrubi-model">Reading and writing Mikrubi model</a><a id="Reading-and-writing-Mikrubi-model-1"></a><a class="docs-heading-anchor-permalink" href="#Reading-and-writing-Mikrubi-model" title="Permalink"></a></h3><p><a href="#Mikrubi.MikrubiModel"><code>MikrubiModel</code></a> is a struct containing transformation parameters. It can be read from and written to disk using respectively <a href="#Mikrubi.readmodel"><code>readmodel</code></a> and <a href="#Mikrubi.writemodel"><code>writemodel</code></a>. </p><article class="docstring"><header><a class="docstring-binding" id="Mikrubi.readmodel" href="#Mikrubi.readmodel"><code>Mikrubi.readmodel</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">readmodel(path::AbstractString)</code></pre><p>Reads a Mikrubi model from file.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Mikrubi.writemodel" href="#Mikrubi.writemodel"><code>Mikrubi.writemodel</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">writemodel(path::AbstractString, model::MikrubiModel)</code></pre><p>Writes a Mikrubi model to file.</p></div></section></article><h2 id="Rasterizing-a-shapefile"><a class="docs-heading-anchor" href="#Rasterizing-a-shapefile">Rasterizing a shapefile</a><a id="Rasterizing-a-shapefile-1"></a><a class="docs-heading-anchor-permalink" href="#Rasterizing-a-shapefile" title="Permalink"></a></h2><p>Rasterization of one or multiple polygon(s) in a shapefile is implemented in the function <a href="#Mikrubi.rasterize"><code>rasterize</code></a>. The implementation is based on such a fact, that a pixel is touched by a polygon (simple or self-intersecting) when and only when either some edge of the polygon runs through the pixel or the center of the pixel lies inside the polygon. Pixels satisfying the two conditions are collected respectively by internal functions <a href="#Mikrubi.scanline"><code>Mikrubi.scanline</code></a> and <a href="#Mikrubi.strokepath"><code>Mikrubi.strokepath</code></a>.</p><article class="docstring"><header><a class="docstring-binding" id="Mikrubi.rasterize" href="#Mikrubi.rasterize"><code>Mikrubi.rasterize</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">rasterize(geom::Shapefile.Polygon, grid::GeoArray)</code></pre><p>Returns coordinates of pixels of <code>grid</code> that <code>geom</code> the polygon(s) touch(es).</p></div></section><section><div><pre><code class="nohighlight hljs">rasterize(shptable::Shapefile.Table, grid::GeoArray)</code></pre><p>Collects coordinates of pixels of <code>grid</code> that every polygon(s) from <code>shptable</code> touch(es).</p></div></section></article><p>When <code>rasterize</code> is applied to an entire shape table (containing multiple counties), its returned value is of an internal type <a href="#Mikrubi.CtPixels"><code>Mikrubi.CtPixels</code></a>.</p><article class="docstring"><header><a class="docstring-binding" id="Mikrubi.CtPixels" href="#Mikrubi.CtPixels"><code>Mikrubi.CtPixels</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">CtPixels</code></pre><p>Alias for <code>Vector{Tuple{Tuple{Int, Int}, Int}}</code>, each element formatted as <code>((i, j), ctid)</code>, where <code>i</code> and <code>j</code> are matrix index on row and column, and <code>ctid</code> is identifier of a county.</p></div></section></article><h4 id="Internal-functions-2"><a class="docs-heading-anchor" href="#Internal-functions-2">Internal functions</a><a class="docs-heading-anchor-permalink" href="#Internal-functions-2" title="Permalink"></a></h4><p>These internal functions are called directly or indirectly inside <a href="#Mikrubi.rasterize"><code>rasterize</code></a>. </p><article class="docstring"><header><a class="docstring-binding" id="Mikrubi.interpolate" href="#Mikrubi.interpolate"><code>Mikrubi.interpolate</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">interpolate(u1::Float64, u2::Float64, v1::Float64, v2::Float64)
interpolate(u1, u2, v1, v2)</code></pre><p>Returns an affine function as a closure, say <code>f</code>, which satisfies <code>f(u1) == v1</code> and <code>f(u2) == v2</code>. </p><p>WARNING: Arguments <code>u1</code> and <code>u2</code> cannot be identical. Beforehand judgement is required. </p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Mikrubi.scanline" href="#Mikrubi.scanline"><code>Mikrubi.scanline</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">scanline(coords::Matrix{Float64}, parts::Vector{&lt;:Integer}, xb, yb)</code></pre><p>Performs scan line algorithm on polygon(s) defined by <code>coords</code> and <code>parts</code>, in the rectangular field ranging from <code>0</code> to <code>xb</code> on longitude and from <code>0</code> to <code>yb</code> on latitude, with grid resolution of <code>1</code> unit. Argument <code>coords</code> is a matrix containing two rows representing longitude and latitude respectively, and <code>parts</code> is a vector of integers denoting starting column index of each ring in the polygon(s). When the center of a pixel lies within the polygon(s), the center coordinates of the pixel are included in the output.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Mikrubi.trimedge" href="#Mikrubi.trimedge"><code>Mikrubi.trimedge</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">trimedge(x1, y1, x2, y2, xb, yb)</code></pre><p>Trims the segment connecting <code>(x1, y1)</code> and <code>(x2, y2)</code> by a rectangle ranging from <code>0</code> to <code>xb</code> on longitude and from <code>0</code> and <code>yb</code> on latitude.</p><p><strong>Example</strong></p><pre><code class="language-julia hljs">julia&gt; trimedge(-2.0, -3.0, 10.0, 6.0, 6.0, 7.0)
(2.0, 0.0, 6.0, 3.0)</code></pre></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Mikrubi.strokeedge" href="#Mikrubi.strokeedge"><code>Mikrubi.strokeedge</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">strokeedge(x1, y1, x2, y2, xb, yb)</code></pre><p>Gathers all unit pixels in the rectangle ranging from <code>0</code> to <code>xb</code> on longitude and from <code>0</code> and <code>yb</code> on latitude that the segment connecting <code>(x1, y1)</code> and <code>(x2, y2)</code> touches.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Mikrubi.strokepath" href="#Mikrubi.strokepath"><code>Mikrubi.strokepath</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">strokepath(coords::Matrix{Float64}, parts, xb, yb)</code></pre><p>Gathers all unit pixels in the rectangle ranging from <code>0</code> to <code>xb</code> on longitude and from <code>0</code> and <code>yb</code> on latitude that the path(s) defined by <code>coords</code> and <code>parts</code> touch(es).</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Mikrubi.geom2mat" href="#Mikrubi.geom2mat"><code>Mikrubi.geom2mat</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">geom2mat(geom::Shapefile.Polygon)</code></pre><p>Converts a <code>Shapefile.Polygon</code> to a two-row matrix, with first row representing the longitudes, and the second for latitudes.</p></div></section></article><h2 id="makefield"><a class="docs-heading-anchor" href="#makefield">Processing the raster layers</a><a id="makefield-1"></a><a class="docs-heading-anchor-permalink" href="#makefield" title="Permalink"></a></h2><p>In Mikrubi, climatic factors after being read in typically undergo some processing steps together with shapefile inside the function <a href="#Mikrubi.makefield"><code>makefield</code></a>, which returns a Mikrubi field and a stack of extracted components in raster layers. The two outputs can be used for training and prediction.</p><p>Sometimes it is also required to apply a model to another circumstance (different time or different space), in which case another series of parallel climatic factor layers need to be processed in exactly the same way as those used to generate the Mikrubi field (so that their climatic meanings are the same). Such layers need to be put in the third place in the input argument list for <a href="#Mikrubi.makefield"><code>makefield</code></a>, and those parallelly extracted components are returned in the third place in output as well.</p><article class="docstring"><header><a class="docstring-binding" id="Mikrubi.makefield" href="#Mikrubi.makefield"><code>Mikrubi.makefield</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">makefield(layers::Vector{&lt;:GeoArray}, shptable::Shapefile.Table; 
	rabsthres=0.8, nprincomp=3)
makefield(layers::Vector{&lt;:GeoArray}, shptable::Shapefile.Table,
	players::Vector{&lt;:GeoArray}; rabsthres=0.8, nprincomp=3)
makefield(layers::Vector{&lt;:GeoArray}, ctpixels::CtPixels; 
	rabsthres=0.8, nprincomp=3)
makefield(layers::Vector{&lt;:GeoArray}, ctpixels::CtPixels,
	players::Vector{&lt;:GeoArray}; rabsthres=0.8, nprincomp=3)</code></pre><p>Generates a Mikrubi field as well as processed variable layers from <code>layers</code>  and <code>shptable</code> or <code>ctpixels</code>, by </p><ol><li>(rasterizing the <code>shptable</code> to <code>ctpixels</code> using <code>rasterize</code>,)</li><li>masking the <code>layers</code> with <code>ctpixels</code> (using <code>Mikrubi.masklayers!</code>),</li><li>extracting non-missing pixels from <code>layers</code> (using <code>Mikrubi.extractlayers</code>),</li><li>selecting less correlated variables (using <code>Mikrubi.selectvars</code>), and</li><li>doing the principal component analysis (using <code>Mikrubi.princompvars</code>).</li></ol><p><strong>Optional keyword arguments</strong></p><ul><li><code>rabsthres</code>: threshold of collinearity.</li></ul><p>Absolute value of Pearson correlation efficient greater than this threshold  is identified as collinearity and the two variables are thus incompatible. </p><ul><li><code>nprincomp</code>: expected number of principal components of the variables.</li></ul><p><strong>Notes about <code>players</code></strong></p><p>when <code>players</code> is present in the argument list, raster layers it contains experience the same process including subsetting, selecting, and taking principal components, and results are packed and returned in the third place. Users must assure that <code>players</code> has the same length as <code>layers</code>, and their elements are corresponding in order. This would be useful when the prediction is in another geographic range or at another time.</p></div></section></article><h4 id="Internal-functions-3"><a class="docs-heading-anchor" href="#Internal-functions-3">Internal functions</a><a class="docs-heading-anchor-permalink" href="#Internal-functions-3" title="Permalink"></a></h4><p>These internal functions are called directly or indirectly inside <a href="#Mikrubi.makefield"><code>makefield</code></a>. Customization is possible when necessary, for example, when the affine transformation during principal component analysis is explicitly wanted.</p><article class="docstring"><header><a class="docstring-binding" id="Mikrubi.masklayers!" href="#Mikrubi.masklayers!"><code>Mikrubi.masklayers!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">masklayers!(layers::Vector{&lt;:GeoArray}, ctpixels::CtPixels)</code></pre><p>Masks the <code>layers</code> in a way that only pixels present in <code>ctpixels</code> are kepts, while all other unmentioned pixels are set to <code>missing</code>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Mikrubi.extractlayers" href="#Mikrubi.extractlayers"><code>Mikrubi.extractlayers</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">extractlayers(layers::Vector{&lt;:GeoArray})</code></pre><p>Extracts the non-<code>missing</code> pixels from the <code>layers</code>, and combines them into a matrix, whose rows representing pixels and columns representing variables.</p><p><code>extractlayers</code> is the inverse function of <code>makelayers</code>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Mikrubi.emptylayer" href="#Mikrubi.emptylayer"><code>Mikrubi.emptylayer</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">emptylayer(grid::GeoArray)</code></pre><p>Creates a <code>GeoArray</code> with the same size and other attributes as <code>grid</code>, but full of <code>missing</code>s in its matrix.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Mikrubi.makelayer" href="#Mikrubi.makelayer"><code>Mikrubi.makelayer</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">makelayer(vector::Vector, idx::Vector, grid::GeoArray)</code></pre><p>Returns a layer according to the grid from <code>grid</code> and content values from  <code>vector</code>. See also <code>makelayers</code>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Mikrubi.makelayers" href="#Mikrubi.makelayers"><code>Mikrubi.makelayers</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">makelayers(matrix::Matrix, idx::Vector, grid::GeoArray)</code></pre><p>Returns a vector of layers according to the grid from <code>grid</code> and content values from columns of <code>matrix</code>. See also <code>makelayer</code>.</p><p><code>makelayers</code> is the inverse function of <code>extractlayers</code>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Mikrubi.dftraverse!" href="#Mikrubi.dftraverse!"><code>Mikrubi.dftraverse!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">dftraverse!(beststate, bestscore, state, score, depth, maxdepth, 
	incompat, scoremat)</code></pre><p>Finds the index combination that</p><ul><li>firstly containing as many indices as possible, and</li><li>secondly with the lowest pairwise sum from submatrix of <code>scoremat</code>,</li></ul><p>such that no indices <code>i</code> and <code>j</code> coexist as long as <code>incompat[i][j] == true</code>.</p><p>The result is stored as the only element of <code>beststate</code>, with its score decided by the two criteria above stored as the only element of <code>bestscore</code>.</p><p><strong>Example</strong></p><pre><code class="language-julia hljs">julia&gt; beststate = Vector(undef, 1);

julia&gt; bestscore = [(0, 0.0)];

julia&gt; dftraverse!(beststate, bestscore, Int[], (0, 0.0), 1, 3,
           Bool[0 0 1; 0 0 0; 1 0 0],
           [0.0 0.6 0.3; 0.6 0.0 0.9; 0.3 0.9 0.0]);

julia&gt; beststate
1-element Array{Any,1}:
 [1, 2]

julia&gt; bestscore
1-element Array{Tuple{Int64,Float64},1}:
 (2, -0.6)</code></pre></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Mikrubi.selectvars" href="#Mikrubi.selectvars"><code>Mikrubi.selectvars</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">selectvars(matrix::Matrix, rabsthres=0.8)</code></pre><p>Selects as many variables as possible from <code>matrix</code> such that no pairwise Pearson coefficient among them exceeds <code>rabsthres</code> and their sum is minimal.</p><p><strong>Example</strong></p><pre><code class="language-julia hljs">julia&gt; selectvars([1. 4. 7.; 2. 5. 8.; 3. 9. 27.], rabsthres=0.9)
2-element Array{Int64,1}:
 1
 3</code></pre></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Mikrubi.princompvars" href="#Mikrubi.princompvars"><code>Mikrubi.princompvars</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">princompvars(submat::Matrix; nprincomp=3)</code></pre><p>Performs principal component analysis on <code>submat</code> whose columns represents variables, and combines the <code>nprincomp</code> principal components into a matrix, and returns the result matrix as well as the affine transformation <code>(colmean, projwstd)</code>, such that the result matrix == <code>(submat .- colmean) * projwstd</code>.</p></div></section></article><h2 id="The-Mikrubi-core"><a class="docs-heading-anchor" href="#The-Mikrubi-core">The Mikrubi core</a><a id="The-Mikrubi-core-1"></a><a class="docs-heading-anchor-permalink" href="#The-Mikrubi-core" title="Permalink"></a></h2><p>Two specially designed structs are involved in the core of Mikrubi.</p><h3 id="Mikrubi-field"><a class="docs-heading-anchor" href="#Mikrubi-field">Mikrubi field</a><a id="Mikrubi-field-1"></a><a class="docs-heading-anchor-permalink" href="#Mikrubi-field" title="Permalink"></a></h3><p><a href="#Mikrubi.MikrubiField"><code>MikrubiField</code></a> is a struct containing mainly three types of information of pixels/points, that is, which counties they belong to (<code>ctids</code>), their geographic coordinates (<code>locs</code>), and their environmental coordinates (<code>vars</code>), with also some derived assistant attributes, such as geographic dimensionality (usually <code>2</code>) and environmental dimensionality (for example, <code>3</code>).</p><p><a href="#Mikrubi.MikrubiField"><code>MikrubiField</code></a> can be obtained in three ways: as first output argument of <a href="#makefield"><code>makefield</code></a>, read from disk, or constructed directly from the three required attributes (this may be useful for simulation analysis). </p><article class="docstring"><header><a class="docstring-binding" id="Mikrubi.MikrubiField" href="#Mikrubi.MikrubiField"><code>Mikrubi.MikrubiField</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">MikrubiField(ctids, locs, vars)</code></pre><p>Constructs a Mikrubi field containing a number of pixels or points, using the arguments which should always have the same number of rows</p><ul><li><code>ctids::Vector</code>: a vector containing the county identifiers</li><li><code>locs::Array{&lt;:Real}</code>: an array of geographic coordinates</li><li><code>vars::Matrix{&lt;:AbstractFloat}</code>: an array of environmental coordinates</li></ul></div></section></article><h3 id="Mikrubi-model"><a class="docs-heading-anchor" href="#Mikrubi-model">Mikrubi model</a><a id="Mikrubi-model-1"></a><a class="docs-heading-anchor-permalink" href="#Mikrubi-model" title="Permalink"></a></h3><p><a href="#Mikrubi.MikrubiModel"><code>MikrubiModel</code></a> contains the environmental dimensionality and the model parameters to define a positive-definite quadratic mapping from environmental space to a real number axis. </p><p>Like <a href="#Mikrubi.MikrubiField"><code>MikrubiField</code></a>, <a href="#Mikrubi.MikrubiField"><code>MikrubiField</code></a> can be obtained in three ways: as output argument of <a href="#fitfuncm"><code>fit</code></a>, read from disk, or constructed directly from attributes. An example of obtaining Mikrubi field and Mikrubi model from constructors are available in <code>examples/onedimsim/sim.jl</code>.</p><article class="docstring"><header><a class="docstring-binding" id="Mikrubi.MikrubiModel" href="#Mikrubi.MikrubiModel"><code>Mikrubi.MikrubiModel</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">MikrubiModel(dvar::Int, params::Vector{&lt;:AbstractFloat})</code></pre><p>Constructs a Mikrubi Model from a dimensionality <code>dvar</code> and a parameter vector <code>params</code>. The equation must hold for <code>dvar2dparam(dvar) == length(params)</code>.</p><p>Mikrubi Models can be obtained from the function <code>fit</code>, and can be used in the function <code>predict</code>.</p></div></section></article><h3 id="fitfuncm"><a class="docs-heading-anchor" href="#fitfuncm">Fitting a Mikrubi model</a><a id="fitfuncm-1"></a><a class="docs-heading-anchor-permalink" href="#fitfuncm" title="Permalink"></a></h3><p>When a Mikrubi field as well as occurrence data in county and/or in coordinates are ready, they can be used to train a Mikrubi model by function <a href="#StatsBase.fit"><code>fit</code></a> (county data at <code>counties</code>, required; coordinates at <code>coords</code>, optional). Result is output as a <a href="#Mikrubi.MikrubiModel"><code>MikrubiModel</code></a>.</p><article class="docstring"><header><a class="docstring-binding" id="StatsBase.fit" href="#StatsBase.fit"><code>StatsBase.fit</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">fit(field::MikrubiField, counties, coords=zeros(0, 0); 
	optresult=[], iterations=3_000_000, kwargs...)</code></pre><p>Numerically finds the Mikrubi model maximizing the likelihood that the occupied counties as well as the occupied coordinates are sampled in the given Mikrubi  field. The optimization result is stored in the container <code>optresult</code> for  debugging.</p></div></section></article><h3 id="Predicting-from-a-Mikrubi-model"><a class="docs-heading-anchor" href="#Predicting-from-a-Mikrubi-model">Predicting from a Mikrubi model</a><a id="Predicting-from-a-Mikrubi-model-1"></a><a class="docs-heading-anchor-permalink" href="#Predicting-from-a-Mikrubi-model" title="Permalink"></a></h3><p>A Mikrubi model can be applied by function <a href="#Mikrubi.predict"><code>predict</code></a> to a matrix with its columns corresponding to extracted variables, a stack of extracted layers, or a Mikrubi field. </p><ul><li>When input argument is a matrix, output argument is a column vector denoting the probability of presence in pixels/points related to rows in the matrix.</li><li>When input argument is a stack of layers, output argument is a single layer denoting the probability of presence.</li><li>When input argument is a Mikrubi field, output argument is a <code>Dict</code> which maps every county identifier to probability of presence at pixels inside the county, see also <a href="#Mikrubi.predictcounty"><code>predictcounty</code></a>.</li></ul><article class="docstring"><header><a class="docstring-binding" id="Mikrubi.predict" href="#Mikrubi.predict"><code>Mikrubi.predict</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">predict(matrix::Matrix, model::MikrubiModel)
predict(layers::Vector{&lt;:GeoArray}, model::MikrubiModel)
predict(field::MikrubiField, model::MikrubiModel)</code></pre><p>Predicts the probability of presence according to processed climatic factors (<code>matrix</code> / <code>layers</code>) or on the Mikrubi field.</p></div></section></article><p>When distribution probability within only one county is concerned, <a href="#Mikrubi.predictcounty"><code>predictcounty</code></a> returns probability of presence at all pixels that constitute the county in descending order. Therefore, the first element represents the most likely occupied pixel of a county.</p><article class="docstring"><header><a class="docstring-binding" id="Mikrubi.predictcounty" href="#Mikrubi.predictcounty"><code>Mikrubi.predictcounty</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">predictcounty(field::MikrubiField, model::MikrubiModel, county)</code></pre><p>Returns the geographic coordinates of pixels in the county sorted by the likeliness of being occupied.</p></div></section></article><p>It is also possible to obtain the overall probability that every county is occupied by the function <a href="#Mikrubi.probcounties"><code>probcounties</code></a>.</p><article class="docstring"><header><a class="docstring-binding" id="Mikrubi.probcounties" href="#Mikrubi.probcounties"><code>Mikrubi.probcounties</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">probcounties(field::MikrubiField{T, U, V}, model::MikrubiModel{V})</code></pre><p>Returns the probability of being occupied for every county in the <code>field</code>. </p></div></section></article><h3 id="Sampling-counties-in-a-Mikrubi-field"><a class="docs-heading-anchor" href="#Sampling-counties-in-a-Mikrubi-field">Sampling counties in a Mikrubi field</a><a id="Sampling-counties-in-a-Mikrubi-field-1"></a><a class="docs-heading-anchor-permalink" href="#Sampling-counties-in-a-Mikrubi-field" title="Permalink"></a></h3><p>For simulation analysis, sometimes it is required to sample a set of counties from a Mikrubi field and a Mikrubi model. <a href="#Mikrubi.samplecounties"><code>samplecounties</code></a> does the trick.</p><article class="docstring"><header><a class="docstring-binding" id="Mikrubi.samplecounties" href="#Mikrubi.samplecounties"><code>Mikrubi.samplecounties</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">samplecounties(field::MikrubiField, model::MikrubiModel)</code></pre><p>Samples the counties according to their probability of being occupied.</p></div></section></article><h3 id="Mathematic-functions"><a class="docs-heading-anchor" href="#Mathematic-functions">Mathematic functions</a><a id="Mathematic-functions-1"></a><a class="docs-heading-anchor-permalink" href="#Mathematic-functions" title="Permalink"></a></h3><p>Two mathematic functions used in the core are exported for convenience.</p><article class="docstring"><header><a class="docstring-binding" id="Mikrubi.logistic" href="#Mikrubi.logistic"><code>Mikrubi.logistic</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">logistic(x)</code></pre><p>Computes <code>logistic(x) := 1 / (1 + e^x)</code>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Mikrubi.loglogistic" href="#Mikrubi.loglogistic"><code>Mikrubi.loglogistic</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">logistic(x)</code></pre><p>Computes <code>log(logistic(x)) = -log(1 + e^x)</code>.</p></div></section></article><h4 id="Internal-functions-4"><a class="docs-heading-anchor" href="#Internal-functions-4">Internal functions</a><a class="docs-heading-anchor-permalink" href="#Internal-functions-4" title="Permalink"></a></h4><article class="docstring"><header><a class="docstring-binding" id="Mikrubi.dvar2dparam" href="#Mikrubi.dvar2dparam"><code>Mikrubi.dvar2dparam</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">dvar2dparam(dvar::Int)</code></pre><p>Transforms dimensionality of an environmental space to the dimensionality of the induced parameter space, i.e., returns the degrees of freedom for  positive-definite quadratic functions mapping a <code>dvar</code>-dimensional linear space into real numbers.</p><p><strong>Examples</strong></p><pre><code class="language-julia hljs">julia&gt; dvar2dparam(1)
3

julia&gt; dvar2dparam(3)
10</code></pre></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Mikrubi.decomparams" href="#Mikrubi.decomparams"><code>Mikrubi.decomparams</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">decomparams(p::Vector, d::Int)
decomparams(model::MikrubiModel)</code></pre><p>Returns parameter decomposition <code>A</code>, <code>b</code>, <code>c</code>, where </p><ul><li><code>A</code> is an upper triangular matrix of size <code>(d, d)</code>,</li><li><code>b</code> is a column vector of size <code>d</code>, and</li><li><code>c</code> is a scalar.</li></ul><p>WARNING: The vector <code>p</code> must have length <code>dvar2dparam(d)</code>.</p><p><strong>Example</strong></p><pre><code class="language-julia hljs">julia&gt; decomparams(collect(1:10), 3)
([1 0 0; 2 3 0; 4 5 6], [7, 8, 9], 10)</code></pre></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Mikrubi.loglike" href="#Mikrubi.loglike"><code>Mikrubi.loglike</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">loglike(field::MikrubiField, params::Vector)</code></pre><p>Computes the log-likelihood of being absent in each pixel given <code>field</code> and <code>params</code>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Mikrubi.energy" href="#Mikrubi.energy"><code>Mikrubi.energy</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">energy(field::MikrubiField, counties, params::Vector)
energy(vars::AbstractMatrix, params::Vector)</code></pre><p>Computes the opposite log-likelihood that the occupied counties or occupied  coordinates are sampled. The result is taken opposite sign for optimization, and therefore the function is called <code>energy</code>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Mikrubi.probpixels" href="#Mikrubi.probpixels"><code>Mikrubi.probpixels</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">probpixels(field::MikrubiField, model::MikrubiModel)</code></pre><p>Returns the probability of being occupied for every pixel in the <code>field</code>. </p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Mikrubi.findnearest" href="#Mikrubi.findnearest"><code>Mikrubi.findnearest</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">findnearest(loc::AbstractVecOrMat{&lt;:Real}, field::MikrubiField)</code></pre><p>Returns the row number in <code>field.locs</code> which is the nearest to the given  coordinates.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Mikrubi.findnearests" href="#Mikrubi.findnearests"><code>Mikrubi.findnearests</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">findnearests(loc::Vector{&lt;:AbstractVecOrMat}, field::MikrubiField)
findnearests(loc::Matrix{&lt;:Real}, field::MikrubiField)</code></pre><p>Returns the row numbers in <code>field.locs</code> which are the nearest to each of the  given coordinates. Duplicate results are reduced to one.</p></div></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../">« Home</a><a class="docs-footer-nextpage" href="../graphics/">Graphics »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.12 on <span class="colophon-date" title="Saturday 4 March 2023 09:08">Saturday 4 March 2023</span>. Using Julia version 1.4.0.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
