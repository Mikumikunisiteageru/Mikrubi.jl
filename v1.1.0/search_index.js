var documenterSearchIndex = {"docs":
[{"location":"manual/#Manual","page":"Manual","title":"Manual","text":"","category":"section"},{"location":"manual/","page":"Manual","title":"Manual","text":"Pages = [\"manual.md\"]\nDepth = 3","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"CurrentModule = Mikrubi","category":"page"},{"location":"manual/#Reading-and-writing","page":"Manual","title":"Reading and writing","text":"","category":"section"},{"location":"manual/#Reading-and-searching-shapefile","page":"Manual","title":"Reading and searching shapefile","text":"","category":"section"},{"location":"manual/","page":"Manual","title":"Manual","text":"Since Mikrubi always reads instead of writes shapefile, only the reading function is offered.","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"readshape","category":"page"},{"location":"manual/#Mikrubi.readshape","page":"Manual","title":"Mikrubi.readshape","text":"readshape(path::AbstractString)\n\nReads a shape (\".shp\") file located at path. Alias for Shapefile.Table.\n\n\n\n\n\n","category":"function"},{"location":"manual/","page":"Manual","title":"Manual","text":"The function lookup is useful when some attribute (e.g. name or code) of a county is known and the row number of the county in a shapefile is wanted (row number acts as identifiers in the list of occupied counties, see the syntax of fit). ","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"lookup","category":"page"},{"location":"manual/#Mikrubi.lookup","page":"Manual","title":"Mikrubi.lookup","text":"lookup(shptable::Shapefile.Table, column::Symbol, entry)\nlookup(shptable::Shapefile.Table, column::Symbol, entries::AbstractArray)\n\nFinds row(s) in the shapefile table whose column record(s) equal(s) to entry or elements of entries. When the third argument is an array, results are output as an array of the same shape by broadcasting.  \n\n\n\n\n\n","category":"function"},{"location":"manual/#Reading-and-writing-list-file","page":"Manual","title":"Reading and writing list file","text":"","category":"section"},{"location":"manual/","page":"Manual","title":"Manual","text":"List of occupied counties can be prepared explicitly in REPL as a vector or a set. Meanwhile, it is also possible to read from or write to disk such a list, especially when the list is generated outside Julia.","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"readlist\nwritelist","category":"page"},{"location":"manual/#Mikrubi.readlist","page":"Manual","title":"Mikrubi.readlist","text":"readlist(path::AbstractString)\n\nReads any list of vector from file.\n\n\n\n\n\n","category":"function"},{"location":"manual/#Mikrubi.writelist","page":"Manual","title":"Mikrubi.writelist","text":"writemodel(path::AbstractString, list::Vector)\n\nWrites any list or vector to file.\n\n\n\n\n\n","category":"function"},{"location":"manual/#Reading-and-writing-raster-layers","page":"Manual","title":"Reading and writing raster layers","text":"","category":"section"},{"location":"manual/","page":"Manual","title":"Manual","text":"Climatic factors are downloaded and stored as raster layers. Mikrubi reads such layers by readlayers, performs principal component analysis on them and returns the results as layers also. When the output layers need to be kept for future use, they can be written to disk using writelayers. Moreover, when the predicted distribution of species is organized in raster format, it can be saved likewise using writelayer.","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"readlayers\nwritelayer\nwritelayers","category":"page"},{"location":"manual/#Mikrubi.readlayers","page":"Manual","title":"Mikrubi.readlayers","text":"readlayers(dir::AbstractString; extset=nothing)\n\nReturns all raster layers as a vector of GeoArrays from the directory dir. All elements in the vector returned are modifiable, and modifications do not affect the files on the disk. \n\nBy setting extset to a container of extensions (e.g. Set(\".tif\"), or [\".tiff\"]), only files ending with its elements are read. Default value is nothing, which means no file extension filtering.\n\n\n\n\n\n","category":"function"},{"location":"manual/#Mikrubi.writelayer","page":"Manual","title":"Mikrubi.writelayer","text":"writelayer(path::AbstractString, layer::GeoArray)\n\nWrites layer to the disk at path. Alias for GeoArrays.write!.\n\n\n\n\n\n","category":"function"},{"location":"manual/#Mikrubi.writelayers","page":"Manual","title":"Mikrubi.writelayers","text":"writelayers(paths::Vector{<:AbstractString}, layers::Vector)\nwritelayers(pathformula::AbstractString, layers::Vector)\n\nWrites layers to paths respondingly, or a series of paths generated by the pathformula where an asterisk is used for wildcard and replaced by numbers.\n\n\n\n\n\n","category":"function"},{"location":"manual/#Internal-functions","page":"Manual","title":"Internal functions","text":"","category":"section"},{"location":"manual/","page":"Manual","title":"Manual","text":"It worths mention that when reading layers from a directory, files are sorted according to their names in a manner similar to the sorting order in Windows OS. Please pay extra attention when two parallel series of raster layers are involved for makefield. ","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"Mikrubi.sortfilenames!","category":"page"},{"location":"manual/#Mikrubi.sortfilenames!","page":"Manual","title":"Mikrubi.sortfilenames!","text":"sortfilenames!(filenames::Vector{<:AbstractString})\n\nIdentifies the distinctive parts among filenames, and sorts filenames according to the order of those parts. If all of the distinctive parts are decimal numerals, they are sorted as integers.\n\nExamples\n\njulia> sortfilenames!([\"bio_9.tif\", \"bio_10.tif\", \"bio_1.tif\"])\n[ Info: Totally 3 raster files recognized in the directory, in the form of bio_*.tif, where asterisk mean 1, 9, 10.\n3-element Array{String,1}:\n \"bio_1.tif\"\n \"bio_9.tif\"\n \"bio_10.tif\"\n\njulia> sortfilenames!([\"bio_09.tif\", \"bio_10.tif\", \"bio_01.tif\"])\n[ Info: Totally 3 raster files recognized in the directory, in the form of bio_*.tif, where asterisk mean 01, 09, 10.\n3-element Array{String,1}:\n \"bio_01.tif\"\n \"bio_09.tif\"\n \"bio_10.tif\"\n\n\n\n\n\n","category":"function"},{"location":"manual/","page":"Manual","title":"Manual","text":"All layers read are copied (so that they are no longer read-only and linking to the files on disk) and replaced extreme values by missings. To change this behavior, please refer to the inner function Mikrubi.copylayer.","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"Mikrubi.copylayer","category":"page"},{"location":"manual/#Mikrubi.copylayer","page":"Manual","title":"Mikrubi.copylayer","text":"copylayer(layer::GeoArray; \n\tfixmissing=true, verylargebase=1_000_000_000_000)\n\nCopies a GeoArray layer (so that the matrix is not read-only).\n\nBy setting fixmissing = true, all pixels with absolute values greater than verylargebase (= 10^12 by default) are identified as missing.\n\n\n\n\n\n","category":"function"},{"location":"manual/#Reading-and-writing-Mikrubi-field","page":"Manual","title":"Reading and writing Mikrubi field","text":"","category":"section"},{"location":"manual/","page":"Manual","title":"Manual","text":"MikrubiField is a specially designed type where the environmental information of pixels and their county identifiers are nested. It may be necessary to save (by writefield) and load (by readfield) a Mikrubi field especially when it is used on multiple species.","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"readfield\nwritefield","category":"page"},{"location":"manual/#Mikrubi.readfield","page":"Manual","title":"Mikrubi.readfield","text":"readfield(path::AbstractString)\n\nReads a Mikrubi field from file.\n\n\n\n\n\n","category":"function"},{"location":"manual/#Mikrubi.writefield","page":"Manual","title":"Mikrubi.writefield","text":"writefield(path::AbstractString, field::MikrubiField)\n\nWrites a Mikrubi field to file.\n\n\n\n\n\n","category":"function"},{"location":"manual/#Reading-and-writing-Mikrubi-model","page":"Manual","title":"Reading and writing Mikrubi model","text":"","category":"section"},{"location":"manual/","page":"Manual","title":"Manual","text":"MikrubiModel is a struct containing transformation parameters. It can be read from and written to disk using respectively readmodel and writemodel. ","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"readmodel\nwritemodel","category":"page"},{"location":"manual/#Mikrubi.readmodel","page":"Manual","title":"Mikrubi.readmodel","text":"readmodel(path::AbstractString)\n\nReads a Mikrubi model from file.\n\n\n\n\n\n","category":"function"},{"location":"manual/#Mikrubi.writemodel","page":"Manual","title":"Mikrubi.writemodel","text":"writemodel(path::AbstractString, model::MikrubiModel)\n\nWrites a Mikrubi model to file.\n\n\n\n\n\n","category":"function"},{"location":"manual/#Rasterizing-a-shapefile","page":"Manual","title":"Rasterizing a shapefile","text":"","category":"section"},{"location":"manual/","page":"Manual","title":"Manual","text":"Rasterization of one or multiple polygon(s) in a shapefile is implemented in the function rasterize. The implementation is based on such a fact, that a pixel is touched by a polygon (simple or self-intersecting) when and only when either some edge of the polygon runs through the pixel or the center of the pixel lies inside the polygon. Pixels satisfying the two conditions are collected respectively by internal functions Mikrubi.scanline and Mikrubi.strokepath.","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"rasterize","category":"page"},{"location":"manual/#Mikrubi.rasterize","page":"Manual","title":"Mikrubi.rasterize","text":"rasterize(geom::Shapefile.Polygon, grid::GeoArray)\n\nReturns coordinates of pixels of grid that geom the polygon(s) touch(es).\n\n\n\n\n\nrasterize(shptable::Shapefile.Table, grid::GeoArray)\n\nCollects coordinates of pixels of grid that every polygon(s) from shptable touch(es).\n\n\n\n\n\n","category":"function"},{"location":"manual/","page":"Manual","title":"Manual","text":"When rasterize is applied to an entire shape table (containing multiple counties), its returned value is of an internal type Mikrubi.CtPixels.","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"Mikrubi.CtPixels","category":"page"},{"location":"manual/#Mikrubi.CtPixels","page":"Manual","title":"Mikrubi.CtPixels","text":"CtPixels\n\nAlias for Vector{Tuple{Tuple{Int, Int}, Int}}, each element formatted as ((i, j), ctid), where i and j are matrix index on row and column, and ctid is identifier of a county.\n\n\n\n\n\n","category":"type"},{"location":"manual/#Internal-functions-2","page":"Manual","title":"Internal functions","text":"","category":"section"},{"location":"manual/","page":"Manual","title":"Manual","text":"These internal functions are called directly or indirectly inside rasterize. ","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"Mikrubi.interpolate\nMikrubi.scanline\nMikrubi.trimedge\nMikrubi.strokeedge\nMikrubi.strokepath\nMikrubi.geom2mat","category":"page"},{"location":"manual/#Mikrubi.interpolate","page":"Manual","title":"Mikrubi.interpolate","text":"interpolate(u1::Float64, u2::Float64, v1::Float64, v2::Float64)\ninterpolate(u1, u2, v1, v2)\n\nReturns an affine function as a closure, say f, which satisfies f(u1) == v1 and f(u2) == v2. \n\nWARNING: Arguments u1 and u2 cannot be identical. Beforehand judgement is required. \n\n\n\n\n\n","category":"function"},{"location":"manual/#Mikrubi.scanline","page":"Manual","title":"Mikrubi.scanline","text":"scanline(coords::Matrix{Float64}, parts::Vector{<:Integer}, xb, yb)\n\nPerforms scan line algorithm on polygon(s) defined by coords and parts, in the rectangular field ranging from 0 to xb on longitude and from 0 to yb on latitude, with grid resolution of 1 unit. Argument coords is a matrix containing two rows representing longitude and latitude respectively, and parts is a vector of integers denoting starting column index of each ring in the polygon(s). When the center of a pixel lies within the polygon(s), the center coordinates of the pixel are included in the output.\n\n\n\n\n\n","category":"function"},{"location":"manual/#Mikrubi.trimedge","page":"Manual","title":"Mikrubi.trimedge","text":"trimedge(x1, y1, x2, y2, xb, yb)\n\nTrims the segment connecting (x1, y1) and (x2, y2) by a rectangle ranging from 0 to xb on longitude and from 0 and yb on latitude.\n\nExample\n\njulia> trimedge(-2.0, -3.0, 10.0, 6.0, 6.0, 7.0)\n(2.0, 0.0, 6.0, 3.0)\n\n\n\n\n\n","category":"function"},{"location":"manual/#Mikrubi.strokeedge","page":"Manual","title":"Mikrubi.strokeedge","text":"strokeedge(x1, y1, x2, y2, xb, yb)\n\nGathers all unit pixels in the rectangle ranging from 0 to xb on longitude and from 0 and yb on latitude that the segment connecting (x1, y1) and (x2, y2) touches.\n\n\n\n\n\n","category":"function"},{"location":"manual/#Mikrubi.strokepath","page":"Manual","title":"Mikrubi.strokepath","text":"strokepath(coords::Matrix{Float64}, parts, xb, yb)\n\nGathers all unit pixels in the rectangle ranging from 0 to xb on longitude and from 0 and yb on latitude that the path(s) defined by coords and parts touch(es).\n\n\n\n\n\n","category":"function"},{"location":"manual/#Mikrubi.geom2mat","page":"Manual","title":"Mikrubi.geom2mat","text":"geom2mat(geom::Shapefile.Polygon)\n\nConverts a Shapefile.Polygon to a two-row matrix, with first row representing the longitudes, and the second for latitudes.\n\n\n\n\n\n","category":"function"},{"location":"manual/#makefield","page":"Manual","title":"Processing the raster layers","text":"","category":"section"},{"location":"manual/","page":"Manual","title":"Manual","text":"In Mikrubi, climatic factors after being read in typically undergo some processing steps together with shapefile inside the function makefield, which returns a Mikrubi field and a stack of extracted components in raster layers. The two outputs can be used for training and prediction.","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"Sometimes it is also required to apply a model to another circumstance (different time or different space), in which case another series of parallel climatic factor layers need to be processed in exactly the same way as those used to generate the Mikrubi field (so that their climatic meanings are the same). Such layers need to be put in the third place in the input argument list for makefield, and those parallelly extracted components are returned in the third place in output as well.","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"makefield","category":"page"},{"location":"manual/#Mikrubi.makefield","page":"Manual","title":"Mikrubi.makefield","text":"makefield(layers::Vector{<:GeoArray}, shptable::Shapefile.Table; \n\trabsthres=0.8, nprincomp=3)\nmakefield(layers::Vector{<:GeoArray}, shptable::Shapefile.Table,\n\tplayers::Vector{<:GeoArray}; rabsthres=0.8, nprincomp=3)\nmakefield(layers::Vector{<:GeoArray}, ctpixels::CtPixels; \n\trabsthres=0.8, nprincomp=3)\nmakefield(layers::Vector{<:GeoArray}, ctpixels::CtPixels,\n\tplayers::Vector{<:GeoArray}; rabsthres=0.8, nprincomp=3)\n\nGenerates a Mikrubi field as well as processed variable layers from layers  and shptable or ctpixels, by \n\n(rasterizing the shptable to ctpixels using rasterize,)\nmasking the layers with ctpixels (using Mikrubi.masklayers!),\nextracting non-missing pixels from layers (using Mikrubi.extractlayers),\nselecting less correlated variables (using Mikrubi.selectvars), and\ndoing the principal component analysis (using Mikrubi.princompvars).\n\nOptional keyword arguments\n\nrabsthres: threshold of collinearity.\n\nAbsolute value of Pearson correlation efficient greater than this threshold  is identified as collinearity and the two variables are thus incompatible. \n\nnprincomp: expected number of principal components of the variables.\n\nNotes about players\n\nwhen players is present in the argument list, raster layers it contains experience the same process including subsetting, selecting, and taking principal components, and results are packed and returned in the third place. Users must assure that players has the same length as layers, and their elements are corresponding in order. This would be useful when the prediction is in another geographic range or at another time.\n\n\n\n\n\n","category":"function"},{"location":"manual/#Internal-functions-3","page":"Manual","title":"Internal functions","text":"","category":"section"},{"location":"manual/","page":"Manual","title":"Manual","text":"These internal functions are called directly or indirectly inside makefield. Customization is possible when necessary, for example, when the affine transformation during principal component analysis is explicitly wanted.","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"Mikrubi.masklayers!\nMikrubi.extractlayers\nMikrubi.emptylayer\nMikrubi.makelayer\nMikrubi.makelayers\nMikrubi.dftraverse!\nMikrubi.selectvars\nMikrubi.princompvars","category":"page"},{"location":"manual/#Mikrubi.masklayers!","page":"Manual","title":"Mikrubi.masklayers!","text":"masklayers!(layers::Vector{<:GeoArray}, ctpixels::CtPixels)\n\nMasks the layers in a way that only pixels present in ctpixels are kepts, while all other unmentioned pixels are set to missing.\n\n\n\n\n\n","category":"function"},{"location":"manual/#Mikrubi.extractlayers","page":"Manual","title":"Mikrubi.extractlayers","text":"extractlayers(layers::Vector{<:GeoArray})\n\nExtracts the non-missing pixels from the layers, and combines them into a matrix, whose rows representing pixels and columns representing variables.\n\nextractlayers is the inverse function of makelayers.\n\n\n\n\n\n","category":"function"},{"location":"manual/#Mikrubi.emptylayer","page":"Manual","title":"Mikrubi.emptylayer","text":"emptylayer(grid::GeoArray)\n\nCreates a GeoArray with the same size and other attributes as grid, but full of missings in its matrix.\n\n\n\n\n\n","category":"function"},{"location":"manual/#Mikrubi.makelayer","page":"Manual","title":"Mikrubi.makelayer","text":"makelayer(vector::Vector, idx::Vector, grid::GeoArray)\n\nReturns a layer according to the grid from grid and content values from  vector. See also makelayers.\n\n\n\n\n\n","category":"function"},{"location":"manual/#Mikrubi.makelayers","page":"Manual","title":"Mikrubi.makelayers","text":"makelayers(matrix::Matrix, idx::Vector, grid::GeoArray)\n\nReturns a vector of layers according to the grid from grid and content values from columns of matrix. See also makelayer.\n\nmakelayers is the inverse function of extractlayers.\n\n\n\n\n\n","category":"function"},{"location":"manual/#Mikrubi.dftraverse!","page":"Manual","title":"Mikrubi.dftraverse!","text":"dftraverse!(beststate, bestscore, state, score, depth, maxdepth, \n\tincompat, scoremat)\n\nFinds the index combination that\n\nfirstly containing as many indices as possible, and\nsecondly with the lowest pairwise sum from submatrix of scoremat,\n\nsuch that no indices i and j coexist as long as incompat[i][j] == true.\n\nThe result is stored as the only element of beststate, with its score decided by the two criteria above stored as the only element of bestscore.\n\nExample\n\njulia> beststate = Vector(undef, 1);\n\njulia> bestscore = [(0, 0.0)];\n\njulia> dftraverse!(beststate, bestscore, Int[], (0, 0.0), 1, 3,\n           Bool[0 0 1; 0 0 0; 1 0 0],\n           [0.0 0.6 0.3; 0.6 0.0 0.9; 0.3 0.9 0.0]);\n\njulia> beststate\n1-element Array{Any,1}:\n [1, 2]\n\njulia> bestscore\n1-element Array{Tuple{Int64,Float64},1}:\n (2, -0.6)\n\n\n\n\n\n","category":"function"},{"location":"manual/#Mikrubi.selectvars","page":"Manual","title":"Mikrubi.selectvars","text":"selectvars(matrix::Matrix, rabsthres=0.8)\n\nSelects as many variables as possible from matrix such that no pairwise Pearson coefficient among them exceeds rabsthres and their sum is minimal.\n\nExample\n\njulia> selectvars([1. 4. 7.; 2. 5. 8.; 3. 9. 27.], rabsthres=0.9)\n2-element Array{Int64,1}:\n 1\n 3\n\n\n\n\n\n","category":"function"},{"location":"manual/#Mikrubi.princompvars","page":"Manual","title":"Mikrubi.princompvars","text":"princompvars(submat::Matrix; nprincomp=3)\n\nPerforms principal component analysis on submat whose columns represents variables, and combines the nprincomp principal components into a matrix, and returns the result matrix as well as the affine transformation (colmean, projwstd), such that the result matrix == (submat .- colmean) * projwstd.\n\n\n\n\n\n","category":"function"},{"location":"manual/#The-Mikrubi-core","page":"Manual","title":"The Mikrubi core","text":"","category":"section"},{"location":"manual/","page":"Manual","title":"Manual","text":"Two specially designed structs are involved in the core of Mikrubi.","category":"page"},{"location":"manual/#Mikrubi-field","page":"Manual","title":"Mikrubi field","text":"","category":"section"},{"location":"manual/","page":"Manual","title":"Manual","text":"MikrubiField is a struct containing mainly three types of information of pixels/points, that is, which counties they belong to (ctids), their geographic coordinates (locs), and their environmental coordinates (vars), with also some derived assistant attributes, such as geographic dimensionality (usually 2) and environmental dimensionality (for example, 3).","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"MikrubiField can be obtained in three ways: as first output argument of makefield, read from disk, or constructed directly from the three required attributes (this may be useful for simulation analysis). ","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"MikrubiField","category":"page"},{"location":"manual/#Mikrubi.MikrubiField","page":"Manual","title":"Mikrubi.MikrubiField","text":"MikrubiField(ctids, locs, vars)\n\nConstructs a Mikrubi field containing a number of pixels or points, using the arguments which should always have the same number of rows\n\nctids::Vector: a vector containing the county identifiers\nlocs::Array{<:Real}: an array of geographic coordinates\nvars::Matrix{<:AbstractFloat}: an array of environmental coordinates\n\n\n\n\n\n","category":"type"},{"location":"manual/#Mikrubi-model","page":"Manual","title":"Mikrubi model","text":"","category":"section"},{"location":"manual/","page":"Manual","title":"Manual","text":"MikrubiModel contains the environmental dimensionality and the model parameters to define a positive-definite quadratic mapping from environmental space to a real number axis. ","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"Like MikrubiField, MikrubiField can be obtained in three ways: as output argument of fit, read from disk, or constructed directly from attributes. An example of obtaining Mikrubi field and Mikrubi model from constructors are available in examples/onedimsim/sim.jl.","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"MikrubiModel","category":"page"},{"location":"manual/#Mikrubi.MikrubiModel","page":"Manual","title":"Mikrubi.MikrubiModel","text":"MikrubiModel(dvar::Int, params::Vector{<:AbstractFloat})\n\nConstructs a Mikrubi Model from a dimensionality dvar and a parameter vector params. The equation must hold for dvar2dparam(dvar) == length(params).\n\nMikrubi Models can be obtained from the function fit, and can be used in the function predict.\n\n\n\n\n\n","category":"type"},{"location":"manual/#fitfuncm","page":"Manual","title":"Fitting a Mikrubi model","text":"","category":"section"},{"location":"manual/","page":"Manual","title":"Manual","text":"When a Mikrubi field as well as occurrence data in county and/or in coordinates are ready, they can be used to train a Mikrubi model by function fit (county data at counties, required; coordinates at coords, optional). Result is output as a MikrubiModel.","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"fit(field::MikrubiField, counties, coords=zeros(0, 0))","category":"page"},{"location":"manual/#StatsBase.fit","page":"Manual","title":"StatsBase.fit","text":"fit(field::MikrubiField, counties, coords=zeros(0, 0); \n\toptresult=[], iterations=3_000_000, kwargs...)\n\nNumerically finds the Mikrubi model maximizing the likelihood that the occupied counties as well as the occupied coordinates are sampled in the given Mikrubi  field. The optimization result is stored in the container optresult for  debugging.\n\n\n\n\n\n","category":"function"},{"location":"manual/#Predicting-from-a-Mikrubi-model","page":"Manual","title":"Predicting from a Mikrubi model","text":"","category":"section"},{"location":"manual/","page":"Manual","title":"Manual","text":"A Mikrubi model can be applied by function predict to a matrix with its columns corresponding to extracted variables, a stack of extracted layers, or a Mikrubi field. ","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"When input argument is a matrix, output argument is a column vector denoting the probability of presence in pixels/points related to rows in the matrix.\nWhen input argument is a stack of layers, output argument is a single layer denoting the probability of presence.\nWhen input argument is a Mikrubi field, output argument is a Dict which maps every county identifier to probability of presence at pixels inside the county, see also predictcounty.","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"predict","category":"page"},{"location":"manual/#Mikrubi.predict","page":"Manual","title":"Mikrubi.predict","text":"predict(matrix::Matrix, model::MikrubiModel)\npredict(layers::Vector{<:GeoArray}, model::MikrubiModel)\npredict(field::MikrubiField, model::MikrubiModel)\n\nPredicts the probability of presence according to processed climatic factors (matrix / layers) or on the Mikrubi field.\n\n\n\n\n\n","category":"function"},{"location":"manual/","page":"Manual","title":"Manual","text":"When distribution probability within only one county is concerned, predictcounty returns probability of presence at all pixels that constitute the county in descending order. Therefore, the first element represents the most likely occupied pixel of a county.","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"predictcounty","category":"page"},{"location":"manual/#Mikrubi.predictcounty","page":"Manual","title":"Mikrubi.predictcounty","text":"predictcounty(field::MikrubiField, model::MikrubiModel, county)\n\nReturns the geographic coordinates of pixels in the county sorted by the likeliness of being occupied.\n\n\n\n\n\n","category":"function"},{"location":"manual/","page":"Manual","title":"Manual","text":"It is also possible to obtain the overall probability that every county is occupied by the function probcounties.","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"probcounties","category":"page"},{"location":"manual/#Mikrubi.probcounties","page":"Manual","title":"Mikrubi.probcounties","text":"probcounties(field::MikrubiField{T, U, V}, model::MikrubiModel{V})\n\nReturns the probability of being occupied for every county in the field. \n\n\n\n\n\n","category":"function"},{"location":"manual/#Sampling-counties-in-a-Mikrubi-field","page":"Manual","title":"Sampling counties in a Mikrubi field","text":"","category":"section"},{"location":"manual/","page":"Manual","title":"Manual","text":"For simulation analysis, sometimes it is required to sample a set of counties from a Mikrubi field and a Mikrubi model. samplecounties does the trick.","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"samplecounties","category":"page"},{"location":"manual/#Mikrubi.samplecounties","page":"Manual","title":"Mikrubi.samplecounties","text":"samplecounties(field::MikrubiField, model::MikrubiModel)\n\nSamples the counties according to their probability of being occupied.\n\n\n\n\n\n","category":"function"},{"location":"manual/#Mathematic-functions","page":"Manual","title":"Mathematic functions","text":"","category":"section"},{"location":"manual/","page":"Manual","title":"Manual","text":"Two mathematic functions used in the core are exported for convenience.","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"logistic\nloglogistic","category":"page"},{"location":"manual/#Mikrubi.logistic","page":"Manual","title":"Mikrubi.logistic","text":"logistic(x)\n\nComputes logistic(x) := 1 / (1 + e^x).\n\n\n\n\n\n","category":"function"},{"location":"manual/#Mikrubi.loglogistic","page":"Manual","title":"Mikrubi.loglogistic","text":"logistic(x)\n\nComputes log(logistic(x)) = -log(1 + e^x).\n\n\n\n\n\n","category":"function"},{"location":"manual/#Internal-functions-4","page":"Manual","title":"Internal functions","text":"","category":"section"},{"location":"manual/","page":"Manual","title":"Manual","text":"Mikrubi.dvar2dparam\nMikrubi.decomparams\nMikrubi.loglike\nMikrubi.energy\nMikrubi.probpixels\nMikrubi.findnearest\nMikrubi.findnearests","category":"page"},{"location":"manual/#Mikrubi.dvar2dparam","page":"Manual","title":"Mikrubi.dvar2dparam","text":"dvar2dparam(dvar::Int)\n\nTransforms dimensionality of an environmental space to the dimensionality of the induced parameter space, i.e., returns the degrees of freedom for  positive-definite quadratic functions mapping a dvar-dimensional linear space into real numbers.\n\nExamples\n\njulia> dvar2dparam(1)\n3\n\njulia> dvar2dparam(3)\n10\n\n\n\n\n\n","category":"function"},{"location":"manual/#Mikrubi.decomparams","page":"Manual","title":"Mikrubi.decomparams","text":"decomparams(p::Vector, d::Int)\ndecomparams(model::MikrubiModel)\n\nReturns parameter decomposition A, b, c, where \n\nA is an upper triangular matrix of size (d, d),\nb is a column vector of size d, and\nc is a scalar.\n\nWARNING: The vector p must have length dvar2dparam(d).\n\nExample\n\njulia> decomparams(collect(1:10), 3)\n([1 0 0; 2 3 0; 4 5 6], [7, 8, 9], 10)\n\n\n\n\n\n","category":"function"},{"location":"manual/#Mikrubi.loglike","page":"Manual","title":"Mikrubi.loglike","text":"loglike(field::MikrubiField, params::Vector)\n\nComputes the log-likelihood of being absent in each pixel given field and params.\n\n\n\n\n\n","category":"function"},{"location":"manual/#Mikrubi.energy","page":"Manual","title":"Mikrubi.energy","text":"energy(field::MikrubiField, counties, params::Vector)\nenergy(vars::AbstractMatrix, params::Vector)\n\nComputes the opposite log-likelihood that the occupied counties or occupied  coordinates are sampled. The result is taken opposite sign for optimization, and therefore the function is called energy.\n\n\n\n\n\n","category":"function"},{"location":"manual/#Mikrubi.probpixels","page":"Manual","title":"Mikrubi.probpixels","text":"probpixels(field::MikrubiField, model::MikrubiModel)\n\nReturns the probability of being occupied for every pixel in the field. \n\n\n\n\n\n","category":"function"},{"location":"manual/#Mikrubi.findnearest","page":"Manual","title":"Mikrubi.findnearest","text":"findnearest(loc::AbstractVecOrMat{<:Real}, field::MikrubiField)\n\nReturns the row number in field.locs which is the nearest to the given  coordinates.\n\n\n\n\n\n","category":"function"},{"location":"manual/#Mikrubi.findnearests","page":"Manual","title":"Mikrubi.findnearests","text":"findnearests(loc::Vector{<:AbstractVecOrMat}, field::MikrubiField)\nfindnearests(loc::Matrix{<:Real}, field::MikrubiField)\n\nReturns the row numbers in field.locs which are the nearest to each of the  given coordinates. Duplicate results are reduced to one.\n\n\n\n\n\n","category":"function"},{"location":"graphics/#Mikrubi-Graphics","page":"Graphics","title":"Mikrubi Graphics","text":"","category":"section"},{"location":"graphics/","page":"Graphics","title":"Graphics","text":"Pages = [\"graphics.md\"]\nDepth = 3","category":"page"},{"location":"graphics/","page":"Graphics","title":"Graphics","text":"CurrentModule = MikrubiGraphics","category":"page"},{"location":"graphics/#Module-introduction","page":"Graphics","title":"Module introduction","text":"","category":"section"},{"location":"graphics/","page":"Graphics","title":"Graphics","text":"MikrubiGraphics is an accessory module of Mikrubi. It illustrates many types of objects involved in Mikrubi including shapefile, raster layer, Mikrubi.CtPixels, and MikrubiField as images, which may be useful while debugging. ","category":"page"},{"location":"graphics/","page":"Graphics","title":"Graphics","text":"Since the plotting engine is substantially the Python package matplotlib (wrapped into Julia by PyPlot.jl), MikrubiGraphics is not imported into the main package. When necessary, users may include this accessory module either by include(\"path/to/Mikrubi/src/MikrubiGraphics.jl\"), or by command using MikrubiGraphics as normal packages after push!(LOAD_PATH, \"path/to/Mikrubi/src/\"), if Python as well as the Python package matplotlib has been installed.","category":"page"},{"location":"graphics/","page":"Graphics","title":"Graphics","text":"showlayer\nshowfield\nshowctpixels\nshowshptable","category":"page"},{"location":"graphics/#MikrubiGraphics.showlayer","page":"Graphics","title":"MikrubiGraphics.showlayer","text":"showlayer(layer; f=identity, kwargs...)\n\nShows a layer. Keyword argument f = identity is a function acted separately on every element. A possible alternative is f = x -> x ^ 0.4. \n\n\n\n\n\n","category":"function"},{"location":"graphics/#MikrubiGraphics.showfield","page":"Graphics","title":"MikrubiGraphics.showfield","text":"showlayer(layer; f=identity, kwargs...)\nshowfield(field, layer; f=tiedrank, kwargs...)\n\nShows geographic information and environmental information of a Mikrubi model. The three principal components are reflexed in red, green, and blue. Keyword argument f = tiedrank is a function acted on columns of field.vars as a  whole. A possible alternative is f = identity.\n\n\n\n\n\n","category":"function"},{"location":"graphics/#MikrubiGraphics.showctpixels","page":"Graphics","title":"MikrubiGraphics.showctpixels","text":"showctpixels(ctpixels, layer; salt=20, kwargs...)\n\nShows a Mikrubi.CtPixels. Every county is assigned a hash color (influenced by a fixed salt value also), and every pixel has the composite color from all counties assigned to it. Empty cells are depicted white.\n\n\n\n\n\n","category":"function"},{"location":"graphics/#MikrubiGraphics.showshptable","page":"Graphics","title":"MikrubiGraphics.showshptable","text":"showshptable(shptable; kwargs...)\n\nShows lines from polygons in shptable. Identical segments are reduced as one.\n\n\n\n\n\n","category":"function"},{"location":"graphics/#The-example-of-*Allium-wallichii*","page":"Graphics","title":"The example of Allium wallichii","text":"","category":"section"},{"location":"graphics/","page":"Graphics","title":"Graphics","text":"In the beginning, here we get the packages, path strings, and decoration functions ready:","category":"page"},{"location":"graphics/","page":"Graphics","title":"Graphics","text":"using Mikrubi\nusing MikrubiGraphics\nusing PyPlot\n\nshpfile = \"path/to/china/counties.shp\";\nlayerdir = \"path/to/worldclim/layers\";\ncountylist = \"path/to/occupied/county/list.txt\";\n\nlargeaxis() = gca().set_position([0.06, 0.07, 0.9, 0.9])\nworldwide() = (xlim(-180, 180); ylim(-90, 90))","category":"page"},{"location":"graphics/#Illustrating-the-shapefile-and-the-raw-layers","page":"Graphics","title":"Illustrating the shapefile and the raw layers","text":"","category":"section"},{"location":"graphics/","page":"Graphics","title":"Graphics","text":"Now the workflow is disassembled into steps, and we use functions implemented in MikrubiGraphics to check the outputs.","category":"page"},{"location":"graphics/","page":"Graphics","title":"Graphics","text":"First of all, a shapefile is read into Julia. We can see clearly that the boundaries of counties of China plotted in black line.","category":"page"},{"location":"graphics/","page":"Graphics","title":"Graphics","text":"shptable = readshape(shpfile)\n\nfigure(figsize=(6.4, 6.4))\nshowshptable(shptable)\nlargeaxis()\nsavefig(\"shpfile.png\")\nclose()","category":"page"},{"location":"graphics/","page":"Graphics","title":"Graphics","text":"(Image: Shapefile)","category":"page"},{"location":"graphics/","page":"Graphics","title":"Graphics","text":"Then, a series of WorldClim climatic factor layers are read in, and the first layer among them is illustrated.","category":"page"},{"location":"graphics/","page":"Graphics","title":"Graphics","text":"layers = readlayers(layerdir)\n\nfigure(figsize=(6.4, 3.2))\nset_cmap(\"viridis\")\nshowlayer(layers[1])\nlargeaxis()\nworldwide()\nsavefig(\"rawlayer1.png\")\nclose()","category":"page"},{"location":"graphics/","page":"Graphics","title":"Graphics","text":"(Image: First WorldClim layer)","category":"page"},{"location":"graphics/#Illustrating-the-rasterization","page":"Graphics","title":"Illustrating the rasterization","text":"","category":"section"},{"location":"graphics/","page":"Graphics","title":"Graphics","text":"Later, counties are rasterized using the grid defined by the layers. Every exclusive pixel is assigned the characteristic color of the county it belongs to, while pixels shared by multiple counties are dyed composite (thus always darker) colors.","category":"page"},{"location":"graphics/","page":"Graphics","title":"Graphics","text":"ctpixels = rasterize(shptable, layers[1])\n\nfigure(figsize=(6.4, 6.4))\nshowctpixels(ctpixels, layers[1])\nshowshptable(shptable, lw=0.5)\ngca().set_aspect(\"auto\")\nlargeaxis()\nsavefig(\"ctpixels.png\")","category":"page"},{"location":"graphics/","page":"Graphics","title":"Graphics","text":"(Image: Rasterization zoom out)","category":"page"},{"location":"graphics/","page":"Graphics","title":"Graphics","text":"Zoom in, and details of the rasterization result are clearer.","category":"page"},{"location":"graphics/","page":"Graphics","title":"Graphics","text":"xlim(88, 98)\nylim(30, 40)\nsavefig(\"ctpixels2.png\")\nclose()","category":"page"},{"location":"graphics/","page":"Graphics","title":"Graphics","text":"(Image: Rasterization zoom in)","category":"page"},{"location":"graphics/#Illustrating-the-extracted-layers-and-the-Mikrubi-field","page":"Graphics","title":"Illustrating the extracted layers and the Mikrubi field","text":"","category":"section"},{"location":"graphics/","page":"Graphics","title":"Graphics","text":"Then, a Mikrubi field is constructed from the results above. Notable, layers lie in the input argument list at both the first and the third places. Layers at the first place are masked by the rasterization result and transformed into fewer (by default, three) layers by principal component analysis, and the results are finally assigned to ylayers here. Meanwhile, layers at the third place undergo the same processes but no masking is applied, whose results are assigned to gylayers. ","category":"page"},{"location":"graphics/","page":"Graphics","title":"Graphics","text":"Now check the images of ylayers[1] and gylayers[1] under the same clim, and we can see that they are actually identical on their overlapping part â€” because they are derived from the same input layers and have experienced the same operations.","category":"page"},{"location":"graphics/","page":"Graphics","title":"Graphics","text":"field, ylayers, gylayers = makefield(layers, ctpixels, layers)\n\nfigure(figsize=(6.4, 5.2))\nshowlayer(ylayers[1])\ngca().set_aspect(\"auto\")\nlargeaxis()\nclim(-6, 2)\nsavefig(\"pcalayer1.png\")\nclose()","category":"page"},{"location":"graphics/","page":"Graphics","title":"Graphics","text":"(Image: First extracted masked layer)","category":"page"},{"location":"graphics/","page":"Graphics","title":"Graphics","text":"figure(figsize=(6.4, 3.2))\nset_cmap(\"viridis\")\nshowlayer(gylayers[1])\nlargeaxis()\nworldwide()\nclim(-6, 2)\nsavefig(\"gpcalayer1.png\")\nclose()","category":"page"},{"location":"graphics/","page":"Graphics","title":"Graphics","text":"(Image: First extracted unmasked layer)","category":"page"},{"location":"graphics/","page":"Graphics","title":"Graphics","text":"At the same time, we may check the Mikrubi field just obtained visually in RGB space (skewed by f = tiedrank in showfield for better image representation). Parts of China are dyed different colors, and the pattern does coincide with our knowledge.","category":"page"},{"location":"graphics/","page":"Graphics","title":"Graphics","text":"figure(figsize=(6.4, 5.2))\nshowfield(field, layers[1])\ngca().set_aspect(\"auto\")\nlargeaxis()\nsavefig(\"field.png\")\nclose()","category":"page"},{"location":"graphics/","page":"Graphics","title":"Graphics","text":"(Image: The Mikrubi field)","category":"page"},{"location":"graphics/#Illustrating-the-predictions","page":"Graphics","title":"Illustrating the predictions","text":"","category":"section"},{"location":"graphics/","page":"Graphics","title":"Graphics","text":"Finally it is the fitting and the predictions. Since the model here is in high dimensionality beyond imagination, we turn to check the images of the predictions. Analogously, under the same clim values, the predicted regional distribution (geodist) and the predicted global distribution (ggeodist) are identical over their overlapping area. Using graphics, we can confirm that everything is in accordance with expectation.","category":"page"},{"location":"graphics/","page":"Graphics","title":"Graphics","text":"ctlist = readlist(countylist)\nmodel = fit(field, ctlist)\ngeodist = predict(ylayers, model)\n\nfigure(figsize=(6.4, 5.2))\nset_cmap(\"CMRmap\")\nshowlayer(geodist, f = x -> x ^ 0.35)\ngca().set_aspect(\"auto\")\nlargeaxis()\nclim(0, 0.45)\nsavefig(\"geodist.png\")\nclose()","category":"page"},{"location":"graphics/","page":"Graphics","title":"Graphics","text":"(Image: Distribution predicted using masked layers)","category":"page"},{"location":"graphics/","page":"Graphics","title":"Graphics","text":"ggeodist = predict(gylayers, model)\n\nfigure(figsize=(6.4, 3.2))\nset_cmap(\"CMRmap\")\nshowlayer(ggeodist, f = x -> x ^ 0.35)\nlargeaxis()\nworldwide()\nclim(0, 0.45)\nsavefig(\"ggeodist.png\")\nclose()","category":"page"},{"location":"graphics/","page":"Graphics","title":"Graphics","text":"(Image: Distribution predicted using unmasked layers)","category":"page"},{"location":"#Mikrubi.jl","page":"Home","title":"Mikrubi.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"A model for species distributions on county-level records.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Mikrubi is a species distribution model (SDM) based on rough occurrences and/or precise coordinates. ","category":"page"},{"location":"","page":"Home","title":"Home","text":"If you want to model the geographic distribution or the ecological niche of a species on its county-level records (or in any other administrative unit) and maybe also with some coordinates, Mikrubi is be a good option.","category":"page"},{"location":"#Workflow","page":"Home","title":"Workflow","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Suppose we want to model the fine-scale distribution of a certain species while knowing its occupied counties of a certain country. To start Mikrubi, we need to prepare three requisites:","category":"page"},{"location":"","page":"Home","title":"Home","text":"A shapefile located at the path shpfile, describing shapes of all counties as polygons. For many countries or regions, such an administrative partition shapefile can be found from Database of Global Administrative Areas. Especially for China, the accepted county-level shapefile is available from National Platform of Common Geospatial Information Services and Gaode Map Open Platform.\nA directory layerdir, containing typically multiple raster layers usually from WorldClim, of the same size, shape, and resolution.  \nA list of integers explicitly provided or written in file at path countylist, each integer of which corresponds to the row number of an occupied county in the shpfile. ","category":"page"},{"location":"","page":"Home","title":"Home","text":"Then the workflow can be summarized as the following:","category":"page"},{"location":"","page":"Home","title":"Home","text":"using Mikrubi\nshptable = readshape(shpfile)\nlayers = readlayers(layerdir)\nfield, ylayers = makefield(layers, shptable)\nctlist = readlist(countylist)\nmodel = fit(field, ctlist)\ngeodist = predict(ylayers, model)\nwritelayer(\"path/to/output/geodist.tif\", geodist)","category":"page"},{"location":"","page":"Home","title":"Home","text":"Now we take Allium wallichii in China as an example (for the same case, codes with more details are also available in examples/alliwalli/workflow.jl; for graphic representation of variables here, please visit Mikrubi Graphics):","category":"page"},{"location":"","page":"Home","title":"Home","text":"julia> using Mikrubi\n\njulia> shptable = readshape(shpfile)\nShapefile.Table{Union{Missing, Shapefile.Polygon}} with 2894 rows and the following 15 columns:\n\ngeometry, id, provinceid, cityid, cocode, coshname, prcode, cishname, cicode, couname, prshname, cifullname, prfullname, countyid, area\n\n\njulia> layers = readlayers(layerdir)\n[ Info: Totally 19 raster files recognized in the directory, in the form of wc2.0_bio_10m_***.tif, where asterisks mean 01, 02, 03, 04, 05, 06, 07, 08, 09, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19.\n19-element Array{GeoArray{Union{Missing, Float64}},1}:\n 2160x1080x1 Array{Union{Missing, Float64},3} with AffineMap([0.16666666666666666 0.0; 0.0 -0.16666666666666666], [-180.0, 90.0]) and CRS GEOGCS[\"WGS 84\",DATUM[\"WGS_1984\",SPHEROID[\"WGS 84\",6378137,298.257223563,AUTHORITY[\"EPSG\",\"7030\"]],AUTHORITY[\"EPSG\",\"6326\"]],PRIMEM[\"Greenwich\",0],UNIT[\"degree\",0.0174532925199433,AUTHORITY[\"EPSG\",\"9122\"]],AXIS[\"Latitude\",NORTH],AXIS[\"Longitude\",EAST],AUTHORITY[\"EPSG\",\"4326\"]]\n ... (18 more omitted)\n\njulia> field, ylayers = makefield(layers, shptable);\n[ Info: Rasterizing procedure may be slow. Please wait...\n################################################################################\n[ Info: Among the 63085 pixels, 369 (0.6%) is/are discarded for lacking values.\n\njulia> field\nMikrubi Field: geo_dim = 2, env_dim = 3, 62716 pixels, and 2893 counties\n\njulia> ylayers\n3-element Array{GeoArray{Union{Missing, Float64}},1}:\n 2160x1080x1 Array{Union{Missing, Float64},3} with AffineMap([0.16666666666666666 0.0; 0.0 -0.16666666666666666], [-180.0, 90.0]) and CRS GEOGCS[\"WGS 84\",DATUM[\"WGS_1984\",SPHEROID[\"WGS 84\",6378137,298.257223563,AUTHORITY[\"EPSG\",\"7030\"]],AUTHORITY[\"EPSG\",\"6326\"]],PRIMEM[\"Greenwich\",0],UNIT[\"degree\",0.0174532925199433,AUTHORITY[\"EPSG\",\"9122\"]],AXIS[\"Latitude\",NORTH],AXIS[\"Longitude\",EAST],AUTHORITY[\"EPSG\",\"4326\"]]\n ... (2 more omitted)\n\njulia> ctlist = readlist(countylist)\n46-element Array{Int64,1}:\n  568\n  162\n  364\n  ...\n  233\n 2768\n 2770\n\njulia> model = fit(field, ctlist)\n[ Info: Maximized log-likeliness: -126.65599400745546\nMikrubiModel{Float64}(3, [1.4842288152354197, -1.3603311815698715, -0.38761691866210646, 1.1231074177981228, 1.2090116395112087, -0.1033479618173679, 14.747024521778938, -14.878922083170924, 11.97056752230023, 30.299436373642205])\n\njulia> geodist = predict(ylayers, model)\n2160x1080x1 Array{Union{Missing, Float64},3} with AffineMap([0.16666666666666666 0.0; 0.0 -0.16666666666666666], [-180.0, 90.0]) and CRS GEOGCS[\"WGS 84\",DATUM[\"WGS_1984\",SPHEROID[\"WGS 84\",6378137,298.257223563,AUTHORITY[\"EPSG\",\"7030\"]],AUTHORITY[\"EPSG\",\"6326\"]],PRIMEM[\"Greenwich\",0],UNIT[\"degree\",0.0174532925199433,AUTHORITY[\"EPSG\",\"9122\"]],AXIS[\"Latitude\",NORTH],AXIS[\"Longitude\",EAST],AUTHORITY[\"EPSG\",\"4326\"]]\n\njulia> writelayer(\"path/to/output/geodist.tif\", geodist)\n\"path/to/output/geodist.tif\"\n","category":"page"},{"location":"#Manual-Outline","page":"Home","title":"Manual Outline","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Pages = [\n    \"manual.md\",\n]\nDepth = 3","category":"page"},{"location":"#Graphics-Outline","page":"Home","title":"Graphics Outline","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Pages = [\n    \"graphics.md\",\n]\nDepth = 3","category":"page"},{"location":"#main-index","page":"Home","title":"Index","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"","category":"page"}]
}
